# x86汇编 算数和逻辑操作指令

包括 **`数据传输指令`**, **`入栈出栈指令`**, **`算数和逻辑操作指令`**,  **`加载有效地址指令`**和**`返回指令`**, 和**寄存器使用规则.**

```ruby
计算指令;
#调用指令
call     mult2          调用 mult2 代码段.
callq    40058b <mult2> 调用函数 mult2 需要使用的地址(40058b).

#数据传送指令
movb     %rl2b, (%bpl)  将 %rl2b 的内容保存在 %bpl 寄存器的值 所指向的内存的位置上. 1字节
movw     0x00ff,%bx     将内存地址 0x00ff 位置的2字节 复制到 %bx 寄存器中. 2字节
movl     $112,2(,%ebx,2)  将立即数 112 存入  %ebx中的值 乘 2 所得到的 内存地址中. 4字节 (注意会将高4字节置0)
movq     %r12, %rbx     将 %r12 寄存器的值, 复制到 %rbx 寄存器. 8字节
movabsq  $0x64位数,寄存器   只能将64位立即数存入 寄存器,而且只能存入寄存器.(完全可以不使用)

movzbw    %rl2b,%bx     将%rl2b中1字节数据进行高位0拓展,填充到2个字节后 存入到%bx寄存器中.
movzwq    %bx, %r14     将%bx 中的2字节数据进行高位0拓展,填充到4个字节后 存入到%r14 寄存器中.
movsbw    %rl2b,%bx     将%rl2b 中的1字节数据通过最高位来进行拓展(1就推展1,0就推展0),然后存入%bx (2字节)
movslq    %ebx,%rax     将%ebx 中的4字节数据通过最高位进行推展(1就推展1,0就推展0),然后存入%rax  (8字节)

#入栈和出栈 指令
pushq     %rbp      将%rbp寄存器的值 入栈(四字),%rsp保存栈顶指针.向下增长,插入元素之前地址减少8字节,然后再插入.栈顶元素地址最低.
popq      %r12      将栈顶的值出栈(四字),先把栈顶内存值写入%r12寄存器,然后%rsp自增8 ,向上增长,删除栈顶元素,地址增加8字节,栈顶元素比原来的值高.

#算数和逻辑操作指令
#一元操作  (都拥有 qlwb 操作, 指定字节大小)
incq     %rbp           将 %rbp 寄存器的值自增1, 然后再存入 %rbp 寄存器. 
decw     %ax            将 %ax  寄存器的值自减1, 然后再存入 %eax 寄存器.
negl     %eax           减 %eax 寄存器的值 进行取负操作,再存入 %rbx 寄存器 ( 2 -> -2)
notd     %al            将 %al  寄存器的值 进行取反操作,再存入 %rbx 寄存器 (1010 -> 0101)

#一元操作 --乘法运算
  #下面乘法指令运行后的结果 高位存放在%rdx中  低位存放在%rax中, 一共是128位 (16个字节)
  #  结果的计算方式 :  long p = x * y;      (W是2^64,x0和x1分别是x的低64位和高64位,y同理)
  #                 p = W(x1*y0+x0*y1+z1) + z0 ;         (理论是: %rdx*2^64+%rax )
  #                   = (x1*W + x0) * (y1*W + y0)
  #                   = (x1*y1*W*W) + W(x1*y0+x0*y1) + x0*y0     (因为x1*y1*W*W超过了128位限制,所以丢弃)
  #                   = W(x1*y0+x0*y1+z1) + z0         (x0*y0还有可能超过64位,将结果假设拆分为 z0和z1 低64和高64)
  #       很明显,需要将x1*y0+x0*y1+z1放到最终结果的高位,即(%rdi),z0放到最终结果的低位,即8(%rdi) 
  #   %rdx寄存器的值 位数从 64开始,而不是0
  #在执行这条指令前, 必须有一个运算参数在 %rax寄存器中,而另一个参数作为指令的源操作数给出.
imulq    %rbx      有符号乘法运算, 后面的q指定四字运算.%rbx的值会被当成参数,与%rax寄存器的值
                     进行运算, 然后乘积的值是128位(16字节),将高位放在%rdx中,低位放在%rax中.
                     也就是说 指令前有 movq一条指令,后面有两条movq指令, 分别进行取出和放入.
                      #例子:   long x,y;   long * d;  
                      #        typedef unsigned __int128 uint128_t;   存放16字节的值
                      #       *d = x * (uint128_t) y;
                      #   d 是 %rdi, x 是%rsi  , y 是%rdx    #
                      #       movq   %rsi, %rax     拷贝x值到%rax寄存器(必须是这个寄存器)
                      #       mulq   %rdx           y与x进行乘法运算,结果默认存入了%rdx和%rax中
                      #       movq   %rax, (%rdi)   将低位的%rax放入 d 的低位地址(小端表示法,从高到低读)
                      #       movq   %rdx, 8(%rdi)  将高位的%rdx放入 d+8 的高位地址(高存高,低存低)
                      #       ret
mulq     %rbx      无符号乘法运算, 后面的q指定四字运算, 和上面相同, 只不过是符号问题罢了

#一元操作 --除法运算
  #除法指令完成后的商保存在 %rax 中, 余数存保存在 %rdx 中. 高位存放在%rdx中  低位存放在%rax中, 一共是128位 (16个字节)
  #被除数保存在 %rdx 寄存器中,而且必须在指令前把被除数保存进去. 然后再使用 cqto 指令进行有符号除法拓展.
    # 当使用无符号除法 divq 时, 不应该使用 cqto  指令, 应该手动初始化 %rdx 为全0.
  #除数参数 应该当作源操作数传递给 idivq或divq 除法指令.
cqto         没有操作数,这条指令隐含读出 %rax 的符号位,并将它复制到 %rdx的所有位. 一般出现在有符号乘除法指令之前.
idivq   %rsi     有符号除法,在这条指令之前需要使用cqto 指令, 然后被除数复制到%rdx中.
                    #例:  long x,y,q,r;     long *qp, *rp; 
                    #     q = x/y ;  r = x%y ;  *qp = q; *rp = r;
                    # x是%rdi, y是%rsi, qp是%rdx, rp是%rcx   # 注意:qp占用了%rdx
                    #  movq   %rdx,%r8    因为qp占用了%rdx 余数寄存器,所以要将原值另存它处
                    #  movq   %rdi,%rax   把被除数x 保存到%rax 被除数寄存器中.
                    #  cqto               因为是有符号除法,所以需要这个来进行符号推展 %rdx
                    #  idivq  %rsi        进行除法,%rax和%rdx是被除数,%rsi是除数.结果的商保存在%rax,余数%rdx
                    #  movq   %rax,(%r8)  将商保存到%r8所指向的内存位置. %rax保存着商.
                    #  movq   %rdx,(%rcx) 将余数给%rcx指向的内存位置,也就是 *rp=x%y; 取模和除法余数结果相等.(优化了)
                    #  ret                没有返回值.直接退出返回上层.
divq    %rsi     无符号除法,大部分操作和有符号相同,但是 cqto 指令变成 movq $0,%rdx .


# 二元操作 --整数运算  (也全都拥有 qlwb 操作, 指定运算字节大小)
subq     $8,%rbp        减法运算, 将%rbp寄存器的值 减去8 这个立即数,然后结果存入%rsp寄存器. 四字运算
                         除此之外还有 subb , subw, subl , 分别是 字节减法,字减法,双字减法
addq     $8,%rbp        加法运算, 将%rbp寄存器的值 加上8 这个立即数,然后结果存入%rsp寄存器. 四字运算
                         除此之外还有 addb , addw, addl , 分别是 字节加法,字加法,双字加法
   
#二元操作 --位运算
xor      %rax,%rbx      异或
or       %rax,%rbx      或
and      %rax,%rbx      与

#移位操作 (第一个操作数必须使用%cl寄存器,或者立即数$,也是有qwlb操作)
#(当寄存器%cl 为 0xff 时,salb会移位7位,salw会移位15位,sall会移位31位, salq会移位63位, 根据qwbl操作会忽略%cl高位)
salb      %cl,%rbx     左移逻辑操作,因为指令尾数是b 所以最多可以位移7位, 将%rbx的值进行位移,然后再存入%rbx
shlw      $12,%rbx     也是左移逻辑操作和sal一摸一摸 没区别, 但是注意 qwlb 只针对 目的操作数,不针对源操作数.
sarl      $3,%rbx      右移算数操作, 进行算数右移, 会补最高位置的值,l表示最多位移31位, 2^5 -1=31
shrq      %cl,%rbx     右移逻辑操作, 进行逻辑右移, 最高位补0. q表示最多移位63位, 2^6 -1 = 63

#加载有效地址
leaq  (%rdi,%rsi,4), %rax   计算前面的源操作数(不是地址),将得到的数据写入 %rax ( 目的操作数必须是寄存器)
                             比如 %rdi =2,%ris=3 通过计算 2+3*4 = 14 那么%rax = 14

#返回指令
ret                     return

nop                     作用是使函数代码变为16字节,提升存储器系统性能,更好放置下个代码块.



############################################################################
############################################################################
############################################################################

寄存器;

%rip     表示pc程序计数器,给出将要执行的下一条指令在内存中的地址.

X86-64有16个64位通用寄存器，分别是：
%rax         作为函数返回值使用。
%rbx ,%rbp ,%r12，%r13，%14，%15   用作数据存储，遵循被调用者使用规则
                                     简单说就是随便用，调用子函数之前要备份它，以防他被修改
%rdi ,%rsi ,%rdx ,%rcx ,%r8，%r9  作为函数参数, 依次对应第1参数，第2参数....
%rsp         栈指针寄存器，指向栈顶.
%r10，%r11   用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值.
```

