# x86汇编 条件码指令, 跳转指令

包括  **`条件码寄存器指令`**, **`跳转指令`**

## 控制 和 指令 以及条件码寄存器

**与`数据相关的控制流`是实现有`条件行为`的更一般和更常见的方法.**

* 两种控制流
  * **测试数据值**
    * **`根据测试的结果来改变控制流或者数据流.`**

**除了整数寄存器, CPU还维护着一组单个位的条件码寄存器\(condition code\).**

### 条件码寄存器

* **条件码寄存器** 
  * **`他们描述了最近的算数和逻辑操作的属性.`**
  * **`可以检测这些寄存器来执行条件分支指令.`**
  * **`所有的算数和逻辑操作都会设置条件码.`**
  * **条件码通常不会直接读取,常用的使用方式有3种:**
    * 可以根据条件码的某种组合,将一个字节设置成0 或者1.
    * 可以条件跳转到程序的某个其他部分.
    * 可以有条件地传送数据.
  * **常用条件码有:**
    * **CF  :**进位标志.   **`最近的操作使最高位产生了进位`. `可以用来检查无符号操作的溢出`.**
      * `(unsigned ) t  <  (unsigned) a`
    * **ZF  :**零标志.       **`最近的操作得出的结果为0`.**
      * `(t == 0)`
    * **SF**  :符号标志.   **`最近的操作得到的结果为负数.`**
      * `(t < 0 )`
    * **OF** :溢出标志.    **`最近的操作导致一个补码溢出 -- 正溢出或负溢出.`**
      * `(a<0 == b<0) && (t<0 != a<0)`

## 条件码指令

```ruby
leaq  指令不会改变任何条件码, 因为它是用来进行地址计算的. 除此之外其余的都会改变条件码.
xor   指令进位标志CF 和溢出标志OF 会设置成0.
      对于位移操作, 进位标志CF 将设为最后一个被移出的位, 而溢出标志OF 会设置为0.
inc 和 dec 指令会设置溢出OF 和 零标志ZF ,但是不会改变进位标志CF.


#设置条件码指令 (不会改变任何寄存器,只设置条件码),都拥有 pwlb操作(1,2,4,8 字节格式)
cmpb   %al,%bl     根据两个操作数之差来设置条件码,类似于sub指令,进行减法 %bl-%al, 可以查看ZF,SF,OF,CF 对比大小.
testw  %ax,%ax     根据两个操作数的 与运算 来设置,%ax & %ax, 可以查看SF,ZF 得到是负数还是0


#访问条件码(注意set指令的后辍与其他的不一样,表示的是不同的条件 而不是操作数大小),考虑的是条件码的组合
#所有set指令的 目的操作数必须是 低位单字节存储器元素之一(%al,%bl),或是一个字节的内存位置, 
#   指令会将这个字节设置为0或者1, 为了得到一个32位或者64位结果, 则必须对高位清零.
#  所有set指令执行之前都会执行上面的设置条件码指令, 具体的组合根据情况判断.
#  这个判断的机制和所需参数都是 来自上一条指令执行之后的 条件码的数值. (cmpq 或 testq).
#   再将得到的 %al 数值高位 置0,  <  movzbl %al ,%eax  >

set     %al   同义名 sete , 操作 %al <- ZF , 判断是否相等 (a==b) 有无符号都可以
setne   %al   同义名 setnz, 操作 %al <- (~ZF), 判断是否不相等(a!= b) 有无符号都可
sets    %al   没有同义名, 操作 %al <- SF , 判断是否是负数,就是小于0. (t<0) 有无符号都可以
setns   %al   没有同义名, 操作 %al <- (~SF), 判断是否是非负数. (t>0) 有无符号都可以

setg    %al   同义名 setnle, 操作 %al <- (~(SF^OF)& (~ZF) , 有符号 大于 ( a > b )有
setge   %al   同义名 setnl , 操作 %al <- (~(SF^OF)) ,  有符号 大于等于  ( a >= b )有
setl    %al   同义名 setnge, 操作 %al <- SF^OF , 有符号 小于 ( a < b)有
setle   %al   同义名 setng,  操作 %al <- (SF^OF)|ZF , 有符号 小于等于 ( a <= b)有

seta    %al   同义名 setnbe, 操作 %al <- (~CF) & (~ZF) , 无符号 超过 ( A > B )无
setae   %al   同义名 setnb,  操作 %al <- ~CF , 无符号 超过或相等 ( A >= B)无
setb    %al   同义名 setnae, 操作 %al <- CF , 无符号 低于  ( A < B)无
setbe   %al   同义名 setna , 操作 %al <- CF|ZF , 无符号 低于或相等 ( A <= B )无

#同义名和指令名功能相同, 编译器和反汇编器会随意决定该使用哪一个.

例子#
    c代码:  int comp(long a, long b) {   return a < b;   }
     汇编:  comp:     #a是寄存器 %rdi,  b是%rsi
               cmpq    %rsi,%rdi        #条件码指令,执行 a-b 重置条件码,但不修改寄存器
               setl    %al              #查看SF和OF条件码. SF^OF 得到的 1 或0 写入%al
               movzbl  %al,%eax         #将%al 无符号0补全,写入%eax,因为是l 所以高4位也置0.
               ret                      #%eax 被拓展之后是 %rax  就是返回值参数寄存器.
```

## 跳转指令

### 用条件控制来实现条件分支

```ruby
GCC 使用较为频繁的还是 条件控制来实现条件分支.

#无条件跳转指令, 
jmp   操作数     # 无条件跳转指令, 有下面两种情况
jmp   .L1        #一.直接跳转(既跳转目标是作为指令的一部分编码的,格式: .标号)
                  #用标号当跳转目标.
jmp   *%rax      #二.间接跳转(即跳转目标是从寄存器或内存位置中读出的,格式: *操作数指示符)
                  # 用寄存器 %rax的值作为跳转目标. 
jmp   *(%rax)    #跳转到 寄存器存储值 所指向 的内存地址中取出跳转目标 并跳转执行.


#有条件跳转指令(直接跳转), 他们都和 条件码相关  CF进位 ,ZF零 ,OF溢出 ,SF符号, PF奇偶
# 满足后面的计算条件  就会跳转, 如果不满足则继续执行序列中下一条指令.
je   .L1       #同义名jz , 操作  ZF  ,相等/零    ( t1 == t2 或 t1 == 0)
jne  .L1       #同义名jnz, 操作  ~ZF  ,不相等/非零   (  t1 != t2 或 t1 != 0 )

js   .L1       #没有同义名. 操作  SF   ,负数    ( t < 0 )
jns  .L1       #没有同义名. 操作  ~SF  ,非负数  ( t > 0 )

jg   .L1       #同义名jnle, 操作 ~(SF^OF)& ~ZF  , 有符号 大于  ( > )
jge  .L1       #同义名jnl , 操作 ~(SF^OF)       , 有符号 大于或等于 ( >= )
jl   .L1       #同义名jnge, 操作 SF^OF          , 有符号 小于  ( < )
jle  .L1       #同义名jng , 操作 (SF^OF)|ZF     , 有符号 小于或等于 ( <= )

ja   .L1       #同义名jnbe, 操作 ~CF & ~ZF   ,无符号  超过 ( > )
jae  .L1       #同义名jnb , 操作 ~CF         ,无符号  超过或相等 ( >= )
jb   .L1       #同义名jnae, 操作 CF          ,无符号  低于 ( < )
jbe  .L1       #同义名jna , 操作 CF | ZF     ,无符号  低于或相等 ( <= )

jp   .L1       #没有同义名, 操作 PF    ,偶1,奇数0), 当PF=1时 跳转,它只查看PF条件码(用于浮点数)

# repz retp  指令的组合很重要,可以加快处理速度.只可以出现在 跳转指令之后,函数的最后两条指令.
例子
 loop:
    movq   %rdi, %rax       
    jmp    .L2            无条件跳转到L2
 .L3:
    sarq   %rax
 .L2:
    testq  %rax,%rax      并运算, 得到原来的值, 重置条件码
    jg     .L3            有条件跳转, 操作  ~(SF^OF)& ~ZF
    rep; ret              rep和repz 同义名, ret和retp 同义名
    
详细解析 十六进制反汇编:  (PC 值很重要,它指向下条指令的地址)
     地址   十六进制机器代码    指令   操作数
     0x0:   48 89 f8         mov   %rdi,%rax
     0x3:   eb 03            jmp   8 <loop + 0x8>     #0x3 + 0x5 = 0x8 地址计算,或者loop+8
     0x5:   48 d1 f8         sar   %rax
     0x8:   48 85 c0         test  %rax,%rax
     0xb:   7f f8            jg    5 <loop + 0x5>     #0xf8 + 0xd = 0x5 地址计算(补码),或者loop+5
     0xd:   f3 c3            repz retq                #retq返回 前面有个repz 很重要.
```

在生成目标代码文件时, 汇编器会确定所有带标号指令的地址,  并将**`跳转目标`**\(目的指令的地址\)编码为跳转指令的一部分.

### 用条件传送来实现条件分支

```ruby
#每条指令有两个操作数: 源寄存器或者内存地址 S 和 目的寄存器 R. ( 指令结果来自于判断条件码的值 )
#    源值可以从内存或者寄存器中读取(不能是单字节),但是只有在指定的条件满足时,才会被复制到目的寄存器中
#    目的值必须是寄存器, 因为汇编器需要从寄存器的名字来判断条件传送指令的操作数长度.
#同条件跳转不同, 处理器无需预测测试的结果就可以执行条件传送. 处理器只是读源值(可能在内存中),检查条件码
#   然后要么更新目的寄存器,要么保持不变.
# a 和 b  以及 t  A  B  这些值都和代码中上面的若干条指令相关.  有可能是0  还有可能是其他.
 
cmove     S,R   同义名cmovz, 传送条件 ZF   ,相等/零  ( t == 0 )
cmovne    S,R   同义名cmovnz,传送条件 ~ZF  ,不相等/非零  ( t != 0 )

cmovs     S,R   没有同义名,   传送条件 SF   ,负数  ( t < 0 )
cmovns    S,R   没有同义名,   传送条件 ~SF  ,非负数 ( t > 0 )

cmovg     S,R   同义名cmovnle, 传送条件 ~(SF^OF)& ~ZF  , 大于 ( a > b ) 有符号
cmovge    S,R   同义名cmovnl , 传送条件 ~(SF^OF)   , 大于或等于 ( a >= b) 有符号
cmovl     S,R   同义名cmovnge, 传送条件 SF^OF      , 小于 ( a < b ) 有符号
cmovle    S,R   同义名cmovng , 传送条件 (SF^OF)|ZF , 小于或等于 (a <= b )  有符号

cmova     S,R   同义名cmovnbe, 传送条件 ~CF & ~ZF  , 超过  ( A > B ) 无符号
cmovae    S,R   同义名cmovnb , 传送条件 ~CF        , 超过或相等  ( A >= B ) 无符号
cmovb     S,R   同义名cmovnae, 传送条件 CF         , 低于 (  A < B ) 无符号
cmovbe    S,R   同义名cmovna , 传送条件 CF | ZF    , 低于或相等  ( A <= B ) 无符号 


例子1:
    C代码.  long arith(long x){
               return  x / 8;
           }
 汇编代码.   x是 %rdi
     arith
          leaq    7(%rdi), %rax    如果被除数x是负数,那么需要加上偏置量 7 来进行运算.
          testq   %rdi,%rdi        执行运算 x&x 然后查看条件码寄存器, 来确定下一步操作.
          cmovns  %rdi,%rax        执行 x > 0  操作, 如果为真, 就把寄存器%rdi的值给%rax, 否则无动作.
          sarq    $3,%rax          执行算数右移操作,移动3次,相当于 /8 操作.
          ret
       
例子2:
    C代码. long test(long x, long y){
              long val = x * 8;
              if( y > 0){
                  if(x < y )
                      val = y - x;
                  else
                      val = x&y;
             }else  if( y <= -2)
                  val = x + y;
             return val;
         }
   汇编代码.  x是%rdi, y 是%rsi
    test: 
         leaq   0(,%rdi,8),%rax   执行 x * 8 ->%rax 操作, val = x*8;
         testq  %rsi,%rsi         测试y的值, 修改条件码寄存器.
         jle    .L2               测试 y<= 0  为真的时候, 跳转到 L2 处执行.
         movq   %rsi,%rax         这里执行  if(y > 0) 处 为真的代码, 将两个值都计算出来,y ->%rax
         subq   %rdi,%rax         执行 y - x, 将结果存入 %rax寄存器
         movq   %rdi,%rdx         这里  x -> %rdx 
         andq   %rsi,%rdx         执行 x&y 操作, 结果在 %rdx中
         cmpq   %rsi,%rdi         执行减法操作, 然后重置条件码 但不修改整数寄存器. x-y
         cmovge %rdx,%rax         执行 >= 操作, 因为上面是减法, 所以这里判断条件是 x 和 y (反转)
         ret                          如果x-y 结果是负数,那么%rax=y-x; 否则就是 %rax=x&y;
     .L2:
         addq   %rsi,%rdi         这部分是 第一个if 的else 语句处, 执行了 x+y -> x
         cmpq   $-2, %rsi         还是减法操作,重置条件码, 但不修改整数寄存器, y- (-2)
         cmovle %rdi,%rax         执行 <= 操作, 因为上面是减法, 判断条件就是 y 和 -2, 查看条件码寄存器
         ret                           y <= -2 操作, 这里要么上面的区分, 因为再后面没有else语句了.

```







