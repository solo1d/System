# 数组分配和访问

## 数组分配和访问

### 基本原则

C语言的一个不同寻常的特点是可以产生指向数组元素的指针,并对这些指针进行运算.  **`在机器代码中`**, **`这些指针会被翻译成地址计算.`**

X86-64的内存引用指令可以用来简化数组访问.

数组定义时的标示符, 可以用作指向数组开头的指针.

```ruby
例如有一个数组定义, 代码为:    int  a[10];        /* 表示是int类型的数组 */
如果访问下标为 5 的数组元素, 那么计算公式是:
                          a + 5 * 4
    有效范围是 0~9
```



### 指针运算

```ruby
C 语言允许对指针进行运算, 而计算出来的值会根据该指针引用的数据类型的大小进行伸缩.
     也就是说, 如果p是一个指向类型为 int 的数据的指针,p的值为 x  
             那么表达式   p+i  的值为  x + 4 * i       
可以对数组和指针应用数组下标操作.
     A[i] 等价于  *( p + i)
     
例子1:
     int a[4]; /* 例如a的值是 0x0012 */
     &a[2] - a  = 2 ;   
        /* 计算过程: 首先取得数组2位置值,再取出值所在的地址,然后减去a地址,得到8,最后除以数据大小*/
        /*  ((a地址 +2*4) - a地址) /4 = 8 / 4 = 2  (得到的值为 long 类型, 因为是地址运算)*/
例子2:
      short b[5];
      b += 3   =   b地址+ 2*3 = b地址+6 ;  /* 因为是short类型, 所以*2, 3 是基数 */
      b + i -1 =   b地址 + 2i - 2 ;    /* 乘2 这个类型大小很重要, 地址运算 */
例子3:
     long c [6];
     *( c +i -3) =  *(c地址 +8i -24) = c[ c地址 +8i -24 ] = c[i -3];
          /* 最后一步剔除了地址, 这是c 的写法, 但是汇编还是需要乘法的 */

```



### 嵌套的数组

```ruby
创建数组的数组时, 数组分配和引用的一般原则也是成立的.
    例如 :  int A[5][3];
         等价于如下声明:
              typedef int row3_t [3];
              row3_t A[5];
数组元素在内存中按照 "行优先" 的顺序排列, 意味着第0行的所有元素,可以写作A[0],
     后面跟着第一行的所有元素(A[1]), 以此类推.
```

![&#x5B58;&#x50A8;&#x7684;&#x6570;&#x7EC4;&#x5143;&#x7D20;&#x4F4D;&#x7F6E;&#x548C;&#x5730;&#x5740;&#x5C31;&#x7B97;&#x89C4;&#x5219;](../.gitbook/assets/ping-mu-kuai-zhao-20190803-17.23.02.png)

```ruby
计算公式:
    对于一个声明如下的数组 :
        int  D [R] [C];     /* R 和 C 都是整形常量 */
    他的数组元素  D [j][t]  的内存地址为:
            &D [j][t]  = x + L(C*j  + t )
                       = x + L(C*j) + L*t
             /* L 是int的类型长度,C 是主要参与运算的常量,可以推算C来得知数组的大小 */

取得二维数组的第一个元素的地址, 也就是数组开始地址:
        int a[4][4];  
        int *p = &a[0][0];     /* 这样就拿到了地址 */
        
        
例子:  
        int a[15][16];  /*int 类型, 字长是4 , 15*16*4 = 960*/
                a[0][0] 是 { a地址 + 4(16 * 0 + 0) } =  a地址
                a[4][5] 是 { a地址 + 4(16 * 4 + 5) } =  a地址 + 276
                a[14][15] 是 { a地址 + 4(16 * 14 + 15) } = a地址 + 956
                     /* 这个结果和上面相差的4, 就是最后一个元素所占的4字节地址位置 */
```



### 定长的数组

定长数组的变化和运算方法与嵌套数组计算公式相同. 需要注意数据类型的字节数.

```ruby
#下面的代码将定长数组的对角线上的元素设置为 val;

    #default  N  16

    void fix_set_diag(int A[N][N], int val){
        long i;
        for(i=0; i<N; i++)
            A[i][i] = val;
    }

经过 gcc -O1 优化之后, 而生成的C 代码:
    void fix_set_diag(int A[N][N], int val){
        int* p = A[0];  /* 等价于 int* p =  &A[0][0]; */
        long i = 0;
        long n = N*(N+1);
        do{
            p[i] = val;
            i += (N+1);
            }while ( i != n );    }

生成的汇编代码:    A是%rdi,  val是%rsi
    fix_set_diag:
        movl     $0,%eax               i = 0
    .L13:
        movl     %esi, (%rdi, %rax)    val的值给到 A+i 的内存地址中
        addq     $68,%rax              i自增, N=16, int是4字节, 4*(16+1) = 4*17= 68 ;
        cmpq     $1088,%rax            i!=1088, 4*(16*(16+1)) = 1088, 实际已经越界了.
        jne      .L13                   !=
        rep;ret
```



### 变长数组

C语言只支持大小在编译时就能确定的多维数组.

变长数组指的是在参数中传递局部变量\(或者表达式\)来作为一个多维数组的维度.

用行优先索引将多维数组映射到一维数组.

```ruby
以下代码适用于 支持变长数组的 ISO C99标准
    计算两个 n*n 矩阵 A 和 B 乘积的元素i,k
原始C代码:
    int var_prod_ele(long n, int A[n][n], int B[n][n], long i, long k){  /* n这个参数*/
        long j ;
        int result = 0;
        for( j=0; j<n ;j++)
            result += A[i][j] * B[j][k];
        return result;
    }
编译器优化后的 C 代码:
    int var_prod_ele(long n, int A[n][n], int B[n][n], long i, long k){
        int *Arow = A[i];    
        int *Bptr = %B[0][k];
        int result = 0;
        long j ;
        for( j=0; j<n; j++){
            result += Arow[j] * (*Bptr);
            Bptr += n;
        }
        return result;
    }
汇编代码:    n是%rdi, Arow是%rsi, Bptr是%rcx, 4n是%r9, result是%eax, j是%edx
    .L24
        movl    (%rsi,%rdx,4),%r8d    读取Arow[j] 的值, 可以看成是一维数组
        imull   (%rcx),%r8d           乘法运算,Bptr指针指向的值 乘 Arow[j] 的值
        addl    %r8d,%rax             将上面的 A[i][0] * B[0][k] 的结果写入 result
        addq    $1,%rdx               j+1
        addq    %r9,%rcx              Bptr+ (4*n), 得到下一行的 B[0][K+1] 的地址
        cmpq    %rdi,%rdx             j != n
        jne    .L24


```











