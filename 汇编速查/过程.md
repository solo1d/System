# 过程 \(栈,局部变量,局部存储空间\)

## 过程

**过程在软件中是一种很重要的抽象**. 它提供了一种封装代码的方式, 用一组指定的参数和一个可选的返回值实现了某种功能.

* **传递控制**
  * **`假设过程P调用过程Q.`** `当进入过程Q的时候, 程序计数器必须被设置为Q的代码的起始地址,然后在返回时,要把程序计数器设置为P中调用Q后面那条指令的地址.`
* **传递数据**
  * `P必须能够向Q提供一个或多个参数, Q必须能够向P返回一个值.`
* **分配和释放内存**
  * `在开始的时候,Q可能需要为局部变量分配空间,而在返回之前又必须释放这些存储空间.`

程序可以用 **栈** 来管理它的过程所需要的 **存储空间**, **栈** 和 **程序寄存器** 存放着 **传递控制** 和**数据**,**分配内存**所需要的**信息**.

x86-64的栈**向低地址方向增长**, 而栈指针 **`%rsp`** 指向栈顶元素.

将栈指针 **减小** 一个适当的量可以为**没有指定初始值的数据** 在栈上**分配空间**. 类似的,可以通过**增加** 栈指针来**`释放空间`**.

当x86-64过程需要的存储空间超过寄存器能够存放的大小时,就会在栈上分配空间,这个部分称为过程的**`栈帧.`**

```ruby
入栈和出栈指令:   ( 栈顶指针 %rsp )
pushq    %rdx    将%rdx寄存器的值入栈.栈指针首先会-8,然后将%rdx的值放入栈指针指向的位置中.
popq     %r12    将栈顶元素的值弹出并赋值给%r12寄存器, 首先取出栈顶值,赋给%r12,然后栈指针+8

调用和返回指令:   (PC 寄存器是 %rip , 下面三条指令有没有q 都一样)
callq    .L1        直接调用, 首先会把调用者callq的下条指令的地址压入栈中, 然后将被调用者的
                       起始地址赋值给PC. (压入的地址称为 返回地址 )
callq    *(%rdi)    间接调用.
retq                返回指令, 将callq指令压入栈中的地址取出来, 赋值给PC. 回到了调用者的位置.
```

## 运行时栈

![](../.gitbook/assets/image.png)

## 栈上的局部存储

一般来说, 通过减小栈指针在栈上分配空间. 分配的结果作为栈帧的一部分,标号为 "**局部变量**".

* 有些时候局部数据必须存放在内存中, 常见的情况有以下几种:
  * 寄存器不足够存放所有的本地数据.
  * 对一个局部变量使用地址运算符 &  ,因此必须能够为它产生一个地址.
  * 某些局部变量是数组或者结构, 因此必须能够通过数组或结构引用被访问到.

```ruby
#代码示例, 栈上局部空间

C 代码:
    proc(long a, long* ap, int b, int* bp, short c, short* cp, char d, char* dp);
    long call_proc(){
        long  x1 = 1;  int  x2 = 2;
        short x3 = 3;  char x4 = 4;
        proc(x1,&x1,x2,&x2,x3,&x3,x4,&x4);
        return (x1 + x2)*(x3 - x4);
    }
汇编代码:
    
call_proc:
    subq      $32,%rsp         建立一个32字节的栈空间
    movq      $1,24(%rsp)      将立即数1 存入栈空间, 32到24 这个范围内空间来存储1, x1
    movl      $2,20(%rsp)      x2
    movw      $3,18(%rsp)      x3
    movb      $4,17(%rsp)      x4
    leaq      17(%rsp), %rax   这个是 &x4 的地址值
    movq      %rax, 8(%rsp)    将&x4 这个地址值放入栈中.这是倒数第一个参数,是第八个参数
    movl      $4, (%rsp)       将x4的值也就是立即数4, 存入栈顶, 是第七个参数
    leaq      18(%rsp), %r9    将x1的栈空间位置地址存入%r9寄存器, 也就是第六个参数
    movl      $3,%r8d          立即数3 是x3的值, 当成参数传入, 第五个参数
    leaq      20(%rsp), %rcx   将 x3 在栈中的地址存入 %rcx, 第四个参数
    movl      $2,%edx          是 x2数值, 存入 %rdx 第三个参数
    leaq      24(%rsp), %rsi   这个是 x1 在栈中的地址, 存入 %rsi 第二个参数
    movl      $1,%edi          将 x1 数值存入 %edi, 第一个参数
    call      proc            准备工作完成, 开始调用 proc
    movslq    20(%rsp),%rdx    开始最后的计算, 将x2的值取出来, 4转8字节 补码方式
    addq      24(%rsp),%rdx    然后再把x1的值取出来, 与x2进行相加
    movswl    18(%rsp),%eax    将x3的值取出来,  2转4  补码方式
    movsbl    17(%rsp),%ecx    再将x4 的值取出来,  2转4 补码方式
    subl      %ecx,%eax        进行减法计算
    cltq                       将%eax 寄存器4字节的值以补码方式拓展成为 %rax 8字节的值
    imulq    %rdx,%rax         乘法运算
    addq     $32,%rsp          将栈空间释放, 上面申请了32, 这里释放32
    ret
```

## 函数参数传递寄存器

| 操作数大小\(位\) | 参数1 | 参数2 | 参数3 | 参数4 | 参数5 | 参数6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 63 | %rdi | %rsi | %rdx | %rcx | %r8 | %r9 |
| 32 | %rdi | %esi | %edx | %ecx | %r8d | %r9d |
| 16 | %di | %si | %dx | %cx | %r8w | %r9w |
| 8 | %dil | %sil | %dl | %cl | %r8b | %r9b |

## 被调用者保存寄存器

| %rbx | %rbp | %r12 | %r13 | %r14 | %r15 |
| :--- | :--- | :--- | :--- | :--- | :--- |


## 寄存器中的局部存储空间

* 寄存器是唯一被所有过程共享的资源
* 所有其他的寄存器, 除了栈指针%rsp, 都分类为 **`调用者保存寄存器.`** \(任何函数都能修改它们\).
* 确保一个过程\(**`调用者`**\) 调用另一过程\(**`被调用者`**\)时, **`被调用者`**不会覆盖**`调用者`**稍后会使用的**寄存器.**
  * 当过程**`P`** 调用过程**`Q`** 时,**`Q`**必须保存上面这些寄存器的值. \(`%rbx`,`%rbp`,`%r12`,`%r13`,`%r14`,`%r15`\), 保证他们的值在**`Q`**返回到**`P`**时与**`Q`** 被调用时是一样的.
  * 过程**`Q`** 保证**`寄存器的值不变`**, 要么就是根本**`不去改变它`**, 要么就是把**`原始值压入栈中,`**改变寄存器的值,然后在返回前从栈中弹出**`旧值`**.    压入栈中的值会在**`栈帧`**中创建标号为 "**`被保存的寄存器`**" 的一部分.

```ruby
C代码:   #两个被调用者保存寄存器, %rbp 和 %rbx
    long Q(long z);
    long P(long x, long y){
        long u = Q(y);
        long v = Q(x);
        return u + v;
    }
汇编代码:  x时%rdi, y是%rsi
 P:
  pushq    %rbp        保存%rbp, 未知的值,因为这个过程需要使用这个寄存器,所以要入栈
  pushq    %rbx        保存%rbx, 同上
  subq     $8,%rsp     对齐堆栈框架, 没什么特殊意义
  movq     %rdi,%rbp   保存x值到%rbp 被调用者保存寄存器
  movq     %rsi,%rdi   将y的值复制给 %rdi 第一个参数寄存器
  call     Q           调用Q过程
  movq     %rax,%rbx   将Q过程的返回值保存到 %rbx 寄存器中, 被调用者寄存器
  call     Q           第二次调用Q过程
  addq     %rbx,%rax   将上面两个Q过程的返回值相加
  addq     $8,%rsp     取消分配堆栈的最后一部分, 就是上面对齐框架的部分
  popq     %rbx        出栈, 还原%rbx的值
  popq     %rbp        出栈, 还原%rbp的值
  ret        
```













