# Y86-64 的顺序实现

**首先在顺序实现之前需要描述一个称为 SEQ\(顺序的\) 处理器.**

**SEQ处理器** : 每个时钟周期上, SEQ执行处理一条完整指令所需的所有步骤. \(但是需要很长的时钟周期时间,因此时钟周期频率会非常低,

**开发SEQ的目标** **`就是提供实现最终目的的第一步`**,  **最终目的是实现一个高效的, 流水线化的处理器.**

## 将处理 组织成阶段

通常处理一条指令包括很多操作.  将它们组织成某个特殊的阶段序列,即使指令的动作差异很大, 但所有的指令都遵循统一的序列.

每一步的具体处理取决于正在执行的指令,  创建一个这样的框架, 就能够设计一个充分利用硬件的处理器.

下面是关于各个阶段以及阶段内执行操作的简略描述:

* **取指\(fetch\):** 取指阶段从内存读取指令字节, 地址为程序计数器\(PC\)的值.
  * 从指令中抽出**`指令指示符`**的**`两个四位部分(第一个字节)`**,称为 icode\(指令代码\) 和 ifun\(指令功能\). 
  * 它可能取出一个**`寄存器指示符字节`**,**指明一个或两个`寄存器操作数指示符`** **rA** 和 **rB**.  它还可能取出一个八字节常数字 **`valC`**
  * 它按顺序方式计算当前指令的下一条指令的地址 **`valP`** . 也就是说**`,valP`**等于**PC的值加上已经取出指令的长度.**
* **译码\(decode\):  译码阶段从寄存器文件读入最多两个操作数, 得到值 `valA` 和/或  `valB`, 通常,它读入指令`rA` 和 `rB` 字段指明的寄存器, 不过有些指令是读寄存器 `%rsp` 的.**
* **执行\(execute\) : 在执行阶段,算术/逻辑单元\(ALU\) 要么执行指令指明的操作 \(根据ifun的值\), 计算内存引用的有效地址, 要么增加或减少栈指针.得到的值称为 valE.**
  * 在此,也可能设置条件码. 对一条 **条件传送指令**来说, **这阶段会检验条件码和传送条件\(由ifun给出\), 如果条件成立, 则更新目标寄存器**.
    * **同样,对于一条跳转指令来说, 这个阶段会决定是不是应该选择分支.**
* **访存\(memory\):  访存阶段可以将数据写入内存, 或者从内存读出数据.  读出的值为 `valM`**
* **写回\( write back\): 写回阶段最多可以写两个结果到寄存器文件.**
* **更新PC \(PC update\) : 将PC 设置成下一条指令的地址.**

**处理器无限循环, 执行上面这些阶段. 当发生异常时处理器就停止: 它执行 `halt`指令或非法指令, 或它试图读或者写非法地址.\(**在更完整的设计中,处理器会进入异常处理模式,开始执行由异常的类型决定的特殊代码\).

![&#x9636;&#x6BB5;&#x5904;&#x7406;](../.gitbook/assets/ping-mu-kuai-zhao-20190813-17.23.59.png)

**整数操作指令的处理遵循上面列出的通用模式.**

**`OP代表ifun 指定的操作 (addq ,subq, andq, xorq).`**

**`执行rrmovq 指令和执行算术运算类似, 不过不需要取第二个寄存器操作数, 我们将ALU 的第二个输入设为0, 先把它和第一个操作数相加,得到 valE = valA, 然后再把这个值写到寄存器文件. 对 irmovq的处理与此类似,除了ALU的第一个输入为常数值 valC. 另外,因为长指令格式, 对于irmovq, 程序计数器必须加10. 所有这些指令都不改变条件码.`**

### 指令序列示例

![&#x662F;&#x4E00;&#x4E2A;&#x793A;&#x4F8B;&#x7A0B;&#x5E8F;, &#x4F9B;&#x4E0B;&#x56FE;&#x8BE6;&#x89E3;](../.gitbook/assets/screen-shot-2019-08-14-at-1.25.39-pm.png)

### \(sub,add,and,xor\)  rrmovq,  irmovq   顺序计算实现

![&#x987A;&#x5E8F;&#x8BA1;&#x7B97;&#x5B9E;&#x73B0;](../.gitbook/assets/screen-shot-2019-08-14-at-6.24.36-pm.png)

![&#x5177;&#x4F53;&#x6848;&#x4F8B;, &#x662F;&#x793A;&#x4F8B;&#x56FE;&#x7684; &#x7B2C;3&#x884C;&#x4E2D; subq &#x6307;&#x4EE4;](../.gitbook/assets/screen-shot-2019-08-14-at-6.30.48-pm.png)

### rmmovq,  mrmovq  顺序计算实现

![](../.gitbook/assets/screen-shot-2019-08-14-at-6.32.20-pm.png)

![&#x793A;&#x4F8B;&#x56FE;, &#x7B2C;5&#x884C;](../.gitbook/assets/screen-shot-2019-08-14-at-6.36.36-pm.png)

### pushq  , popq  顺序实现

![](../.gitbook/assets/screen-shot-2019-08-14-at-6.41.12-pm.png)

![&#x793A;&#x4F8B;&#x56FE;, &#x7B2C;6&#x884C;](../.gitbook/assets/screen-shot-2019-08-14-at-6.42.41-pm.png)

###  call  ,ret,  jXX\(jmp,jne.....\)  三类控制转移指令

![cnd &#x662F;&#x5206;&#x652F;&#x4FE1;&#x53F7;](../.gitbook/assets/screen-shot-2019-08-14-at-6.44.44-pm.png)

![&#x793A;&#x4F8B;&#x56FE;, &#x7B2C;8&#x884C;](../.gitbook/assets/screen-shot-2019-08-14-at-6.49.28-pm.png)

![&#x793A;&#x4F8B;&#x56FE;, &#x7B2C;13&#x884C;](../.gitbook/assets/screen-shot-2019-08-14-at-6.50.29-pm.png)

