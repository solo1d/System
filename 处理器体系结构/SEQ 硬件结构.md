# SEQ 硬件结构

## SEQ抽象视图

![SEQ&#x62BD;&#x8C61;&#x56FE;,&#x6240;&#x6709;&#x786C;&#x4EF6;&#x5355;&#x5143;&#x7684;&#x5904;&#x7406;&#x90FD;&#x5728;&#x4E00;&#x4E2A;&#x65F6;&#x949F;&#x5468;&#x671F;&#x5185;&#x5B8C;&#x6210;](../.gitbook/assets/screen-shot-2019-08-14-at-7.32.53-pm.png)

实现所有 Y86-64 指令所需要的计算可以被组织成6个基本阶段: **取指,译码,执行,访存,写回,PC更新.**

* **取指**
  * **`将程序计数器寄存器作为地址, 指令内存读取指令的字节. PC增加器 计算 valP, 即增加了程序计数器`**
* **译码**
  * 寄存器文件有两个端口**`A和B,`** 从这两个端口同时**读寄存器值`valA`** 和 **`valB`**.
* **执行**
  * **`执行阶段会根据指令的类型,将算术/逻辑单元(ALU) 用于不同的目的.`** 
    * **对整数操作**, 它要执行指令所指定的运算. **对其他指令**, 它会作为一个加法来计算增加或减少栈指针, **或者计算有效地址**,**或者只是简单的增加0, 将一个输入传递到一个输出.**
  * **条件码寄存器\( CC \) 有三个条件码位.   ALU 负责计算条件码的新值.**
    * 当执行条件传送指令时, 根据条件码和传送条件来计算决定是否更新目标寄存器.
    * 同样, 当执行一条 条件跳转指令时, 会根据条件码和跳转类型来计算分支信号 **`Cnd.`**
* **访存**
  * **在执行访存操作时, 数据内存`读出`或`写入`一个内存字.**
    * 指令和数据内存访问的是**`相同的内存位置`**,**但是用于不同的目的.**
* **写回**
  * **寄存器文件有两个写端口**
    *  **端口`E` 用来写 `ALU` 计算出来的值**
    * **端口 `M`  用来写入`数据内存`中读出的值**
* **PC更新**
  * 程序计数器的新值选择自:
    * **`valP`**   , 下一条指令的地址  \( **`valP = PC + 已读的指令字节`** \)
    * **`valC`**  ,  调用指令或跳转指令指定的目标地址 \( **`call 地址 , jmp  地址`** \)
    * **`valM`** ,  从内存读取的返回地址 \( **`ret`** \)

### 实现 SEQ 所需要的硬件

![&#x786C;&#x4EF6;&#x7ED3;&#x6784;](../.gitbook/assets/screen-shot-2019-08-15-at-8.11.40-am%20%281%29.png)

* **白色方框** 
  * 表示**`时钟寄存器`**.  **`程序寄存器PC`** 是SEQ 中唯一的时钟寄存器.
* **浅蓝色方框**
  * 表示硬件单元 包括,内存,ALU等等.
* **灰色矩形方框**
  * 表示控制逻辑块,这些块用来从一组信号源中进行选择,或者用来计算一些布尔函数.
* 白色圆圈
  * 它们是线路的标识, 不是硬件单元
* **粗线**
  * 每条这样的线都代表一簇64根线,并列连接在一起, 将一个字从硬件的一部分传送到另一部分.
* **细线**
  * 根据线上要携带的值的类型,每条这样的线实际上都代表一簇 4或8根线.
* **虚线**
  * **代表芯片上单元与块之间传递的控制值.**

**指令序列中所有的计算都有这样的性质, 每一行都代表某个值的计算\(如valP\), 或激活某个硬件单元\(如内存\).**

![](../.gitbook/assets/screen-shot-2019-08-15-at-2.03.46-pm.png)

**上图中, 我们要实现的控制逻辑, 它能在不同硬件单元之间传送数据, 以及操作这些单元, 使得对每个不同的指令执行指定的运算.**  _**`这就是控制逻辑块的目标`**_

## SEQ  的时序 \(重要\)

在**`处理组织成阶段`** , 它们是用符号写的, 那些赋值是从上到下顺序执行的. _**`然而,与硬件结构的运行根本不同, 一个时钟变化会引发一个经过组合逻辑的流, 来执行整个指令.`**_ 

* **SEQ 的实现包括`组合逻辑`和`两种存储器设备`:**
  * **存储设备:**
    * **时钟寄存器 \( `程序计数器` 和 `条件码寄存器`\)**
    * **随机访问存储器 \(`寄存器文件`, `指令内存和数据内存`\)**
  * **组合逻辑 `不需要任何时序` 或`控制` ,   `只要输入变化了,值就通过逻辑门网络传播`**
    * 也可以将随机访问存储器堪称和组合逻辑一样的操作, 根据地址输入产生字.
    * 由于指令内存用来读指令, 因此我们可以将整个单元看成是组合逻辑.

**还有四个硬件单元需要对他们的时序进行明确的控制**

* **`程序计数器`, `条件码寄存器`, `数据内存` 和 `寄存器文件`**
  * 这些单元通过一个时钟信号来控制, 它触发新值装载到寄存器, 以及将值写到随机访问存储器.
  * 每个时钟周期, 程序计数器都会装载新的指令地址. 只有在执行整数运算指令时,才会装载条件码寄存器.
  * 只有在执行 rmmovq,pushq,或 call  指令时,才会写数据内存.
  * 寄存器文件的两个写端口允许 **每个时钟周期更新两个程序寄存器**, 不过可以用特殊寄存器**ID 0xF** 作为端口地址, 来表明此端口不应该执行写操作.

**要控制处理器中活动的时序, 只需要寄存器和内存的时钟控制.**

```text
原则:  从不会回读
    处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态.

这条原则对实现的成功至关重要.
```



![&#x8FD9;&#x5F20;&#x56FE;&#x81F3;&#x5173;&#x91CD;&#x8981;](../.gitbook/assets/screen-shot-2019-08-15-at-2.37.36-pm.png)

* 条件码的顺序是  ZF,SF,OF 
* **不同颜色的代码表明电路信号是如何在被执行的不同指令相互联系的**

![](../.gitbook/assets/screen-shot-2019-08-15-at-3.11.00-pm.png)

![](../.gitbook/assets/screen-shot-2019-08-15-at-3.11.14-pm.png)

## SEQ 阶段的实现

**设计实现 SEQ 所需要的控制逻辑块 HCL 描述.**

![SEQ&#x7684;HCL&#x5E38;&#x6570;&#x63CF;&#x8FF0;, &#x5E38;&#x6570;&#x503C;&#x90FD;&#x662F;&#x5927;&#x5199;&#x7684;](../.gitbook/assets/screen-shot-2019-08-15-at-6.45.00-pm.png)

```text
nop    指令只是简单的经过各个阶段, 除了要将PC 加一,不进行任何处理.
halt   指令是的处理器状态被设置为 HLT, 导致处理器停止运行.
```

### 1. 取指阶段

![&#x53D6;&#x6307;&#x9636;&#x6BB5;](../.gitbook/assets/screen-shot-2019-08-15-at-6.49.41-pm.png)

**取指阶段 包括指令内存硬件单元.   以PC作为第一个字节\(字节0\) 的地址, 这个单元一次从内存中读出10个字节**

* **第一个字节被解释称指令字节\(标号为 "Split" 的单元\),   分为两个 4 位的数**
  * **前4位,是  icode, 后四个字节是  ifun**
    * 标号为 “**`icode`**“  和 "**`ifun`**"  的控制逻辑块计算指令和功能码.或者使之等于从内存读出的值, 或者使之等于从内存读出的值, 或者当指令不合法时 \(由信号 **`imem_error`** 指明\), 使这些值对应于 **nop** 指令.
    * **根据 icode 的值, 我们可以计算三个一位的信号\( 虚线表示\)**
      * **instr\_valid:  这个字节 为1 时, `表示发现不合法的指令`**
      * **need\_regids : 这个字节为1时, `表示有两个寄存器指示符字节`**
      * **need\_valC:   这个字节为1时, `表示指令有个常数字参数`**
    * 当指令地址越界时会产生信号  "**`instr_valid`** " 和 "**`imem_erroe`**" 在访存阶段被用来产生状态码.
    * **need\_regids  的 HCL 描述,只确定了 icode 的值是否为一条带有寄存器指示值字节的指令**
      * `bool need_regids =  icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ };`
    * **need\_valC 的 HCL 描述,  为了确定 icode 的值是否有常数参数**
      * `bool  need_valC =  icode in { IIMMOVQ, IJXX, ICALL, IMRMOVQ , IRMMOVQ }`
* **从指令内存中读出剩下的9个字节 是寄存器指示符字节和常数字的组合编码 , 标号为 "Align" 的硬件会处理这些字节**
  * 将它们分别放入寄存器字段和常数字中
    * 当被计算出的信号  " need\_regids “ 为 1 时, 字节1被分开装入寄存器指示符 rA 和 rB 中, 否则这两个字段会被设为 0xF\(RNONE\),  表明这条指令没有指明寄存器.
    * 任何只有一个寄存器操作数的指令, 寄存器指示字节的另一个字段都设为 0XF \(RNONE\)
      * 因此,可以将信号 rA 和 rB 看成, 要么放着我们要访问的寄存器, 要么表明不需要访问任何寄存器
    * 这个 标号为 "Align" 的单元还产生常数字 valC.
    * 根据信号 need\_regids 的值, 要么根据字节 1~8来产生 valC,  要么根据2~9 来产生.

PC  增加器硬件单元根据当前PC 以及两个信号 need\_regids 和 need\_valC 的值, 产生信号 valP. 对于 PC 值 p,  need\_regids值 r 以及 need\_valC 值 i ,增加器产生值:

$$
PC值 = p + 1 + r +8i
$$

### 2. 译码 和 写回阶段

**译码和写回都需要访问寄存器文件.**

![](../.gitbook/assets/screen-shot-2019-08-16-at-10.47.15-am.png)

* 寄存器文件有4个端口, 每个端口都有一个**地址连接**\(**`寄存器ID`**\)和一个**数据连接**\(**`一组64根线路`**\)
  * **两个读端口 \( A 和 B  \)**    
    * 地址分别是  **`srcA`**   和 **`srcB`**
      * **`srcA 和 srcB  表示该读那个寄存器以产生 valA  和 valB.`** 
        * **`srcA 的 HCL 描述:`**
          * `word srcA = [  icode in {IRRMOVQ , IRMMOVQ, IOPQ, IPUSHQ } : rA; icode in {IPOPQ, IRET} : RRSP;      1:RNONE;#最后这个表示不需要访问寄存器  ]`
        * **`srcB 的 HCL 描述:`**
          * `word  srcB = [ icode in {IOPQ , IRMMOVQ, IMRMOVQ } : rB;    icode in {IPUSHQ , IPOPQ, ICALL, IRET } : RRSP;    1 : RNONE; ]`
  * **两个写端口 \( E 和 M \),  只有  popq 指令会同时用到寄存器文件的两个写端口.**
    * 地址分别是 `dstE`  和 `dstM`,  **优先级 valE先写入,valM后写入, 但是 valE的值有可能会被valM覆盖 \( `popq %rsp` \)**
      * `word dstE = [  icode in { IRRMOVQ } : rB;  icode in { IIRMOVQ, IOPQ }:rB;  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP ;   1:RNONE;  ]`
      * * `word dstM = [  icode in { IMRMOVQ, IPOPQ , } :rA;    1:RNONE;  ]`
  * 如果某个地址端上的值为特殊标识符  **0xF**\(**RNONE**\), 则表明**不需要访问寄存器**

根据指令代码  **`icode`** 以及寄存器指示值 **`rA`** 和 **`rB`** ,可能会根据执行阶段计算出 **`Cnd 条件信号`**,

**图中 底部的 四个块\(dstE,dstM,srcA,srcB\) 产生出四个不同的寄存器文件的寄存器ID.**

### 3. 执行阶段

![ALU](../.gitbook/assets/screen-shot-2019-08-16-at-2.10.47-pm.png)

执行阶段包括算术/逻辑单元\( ALU \). 这个单元根据 alufun 信号的设置,对输入 aluA 和 aluB 执行 ADD ,SUBTRACT ,AND 或 EXCLUSIVE-OR运算.

这些数据和控制信号是由三个控制块产生的\(ALUfun.   ALUA, LUAB\),  ALU的输出就是valE 信号\(值\).

* 执行阶段的第一步就是每条指令的 ALU 计算.
  * 列出操作数 aluB 在前面, aluA 在后面, 这样做是为了保证 subq 指令是 valB减去valA
  * 根据指令类型, aluA 的值可以是 valA , valC , 或者是 -8 或+8.
  * aluA的控制块行为:
    * `word aluA = [  icode in { IRRMOVQ, IOPQ } : valA;          icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : valC;          icode in { ICAL , IPUSHQ } : -8;     icode in { IRET,  IPOPQ } :8;         ]`
* **ALU在执行阶段执行的操作**
  * 每次运行 ALU 都会产生三个与条件码相关的信号  - 零,符号和溢出.
    * 但是只能在执行 OPq 指令时才设置条件码.  因此产生了一个信号 set\_cc 来控制是否更新条件码
      * `bool  set_cc = icode in { IOPQ };`
* 标号为  “cond“  的硬件单元会根据条件码和功能码来确定是否进行条件分支或者条件数据传送.
  * 他产生信号 Cnd ,  用于设置条件传送 dstE ,也用于田间分支的下一个 PC 逻辑中.
  * 对于其他指令, 取决于指令的功能码和条件码的设置,  Cnd 信号可以被设置为1或者0
    * 但是控制逻辑会忽略它.

```text
条件传送
word  dstE = [
    icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL , IPUSHQ, IRET , IPOPQ } :valB;
    icode in { IRRMOVQ, IIRMOVQ } 0;
]
```

### 4. 访存阶段

**访存阶段的任务 就是读或写程序数据.**

![](../.gitbook/assets/screen-shot-2019-08-16-at-4.43.29-pm.png)

**两个控制块\(`Mem.addr, Mem.data`\)产生内存地址和内存输入数据\(为写操作\)的值.**

**另外两块 \( `Mem.read, Mem.write` \) 产生表明应该执行读操作还是写操作的控制信号.\(当执行读操作时, 数据内存产生值 `valM` \).**

**内存地和写的地址总是 valE 或 valA.**  

```text
HCL 描述:
word mem_addr = [
        icode in  { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ } : valE;
        icode in  { IPOPQ , IRET } :valA;
];

word  mem_data = [
        icode in { IRMMOVQ, IPUSHQ } :valA;
        icode  == ICALL : valP;
]

从内存中读数据 并设置控制信号 mem_read
bool mem_read = icode in { IMRMOVQ, IPOPQ, IRET };

向内存写数据的指令并设置控制信号 mem_write
bool mem_write = icode in { IRMMOVQ, IPUSH, ICALL } ;

访存阶段的最后功能是根据取指阶段产生的 icode, imem_error(地址不合法,1不合法,0合法),
    instr_valid(指令不合法,0不合法,1合法)值,以及数据内存产生的dmem_error(1不合法,0合法)信号,
        从指令执行的结果来计算状态码 Stat
word Stat = [
        imem_error || dmem_error : SADR;
        !instr_valid : SINS;
        icode == IHALT : SHLT;
        1 : SAOK;
]
```

## 5. 更新PC阶段

![](../.gitbook/assets/screen-shot-2019-08-16-at-5.03.52-pm.png)

SEQ 中最后一个阶段产生程序计数器的新值.

**根据指令的类型和是否要选择分支, 新的PC可能是 valC,  valM 或 valP.**

```text
word   new_pc  = [
    icode == ICALL :valC;
    icode == IJXX && Cnd : valC;
    icode == IRET : valM;
]
```

### 6. 小结

**可以用各种硬件单元以及一个时钟来控制计算的顺序, 从而实现整个处理器.**

**SEQ唯一的问题就是它太慢了, 时钟必须非常慢, 以使信号能在一个周期内传播所有的阶段.**

**这种方法不能充分利用硬件单元, 因为每个单元只在整个时钟周期的一部分时间内才被使用.\( 可以引用流水线来获得更好的性能\)**

