# 网络编程

我们需要理解基本的`客户端-服务端`编程模型，以及如何编写使用因特网提供的服务的`客户端-服务端`程序。

最后，我们将把所有这些概念结合起来，开发一个小的但功能齐全的`Web`服务器，能够为真实的`Web`浏览器提供静态的和动态的文本和图形内容。

## 客户端-服务器编程模型

每个网络应用程序都是基于`客户端 - 服务器模型`的

**客户端和服务器都是进程.而不是机器或主机.**

* 采用这种模型，一个应用是由一个`服务器`进程 和一个或多个客户端`进程`组成。
  * `服务器`管理某种资源，并且通过操作这种资源为它的客户端提供某种服务。
    * `WEB`服务器，代表`客户端`检索，执行磁盘内容。
    * `FTP`服务器，为`客户端`进行存储和检索。
    * `电子邮件`服务器，为`客户端`进行读和更新。
  * `客户端-服务器`模型中的基本操作是`事务(transaction)`.
    * 一个`客户端-服务器`事务由四步组成
      * 客户端需要服务的时候，向服务器发送请求，发送一个`事务`。
      * 服务器收到请求后，解释它，并以适当方式操作它的资源。
      * 服务器给客户端发送一个`响应`，并等待下一个请求。
      * 客户端收到`响应`并处理它。
    * **事务仅仅是客户端和服务器执行的一系列步骤.**

![g](.gitbook/assets/ping-mu-kuai-zhao-20190925-xia-wu-8.03.20.png)

## 网络

`客户端`和`服务端`通常运行在不同的主机上，并且通过`计算机网络`的硬件和软件资源来通信。

* 对于一个主机而言，`网络`只是又一种`I/O`设备，作为**数据源**和**数据接收方**。

![h](.gitbook/assets/UWEx308.png)

* 对于物理上而言，网络是一个按照地理远近组成的层次系统。
  * 最低层是`LAN(Local Area Network,局域网)`:在一个建筑或校园范围内。
    * 迄今为止，最流行的`LAN`技术是`以太网(Ethernet)`.
      * 由`Xerox PARC`公司在20世纪70年代中期提出。
        * `以太网`被证明是适应力极强的，从`3 MB/s`到`10 GB/s`。
      * 一个`以太网段(Ethernet segment)`
        * ![h](.gitbook/assets/P4ZTZdh.png)
        * 包括一些`电缆(通常是双绞线)`和一个叫做`集线器`的小盒子。
          * 每根`电缆`都有相同的最大位带宽
            * 典型的是`100MB/s`或者`1GB/S`.
            * 一端连接在主机的`适配器`，一端连接到集线器的`一个端口`。
          * `集线器`不加分辨地将从一个端口收到的每个位复制到其他所有端口上。
            * 因此每台主机都能看到每个位。
        * `以太网段`通常跨越一些小的区域。
          * 例如某建筑物的一个房间或一个楼层。

扩展介绍`以太网`

每个`以太网适配器(网卡)`都有一个全球唯一的`48`位地址，它存储在这个适配器的`ROM`上\(`MAC`\)。

* 一台主机可以发送一段`位`，称为`帧(frame)`，到这个`网段`内其他任何主机。
  * 每个`帧`包括
    * 一些固定数量的`头部(header)`位
      * 用于表示此`帧`的源，和目的地址以及此`帧`的长度。
    * 此后就是数据位的`有效载荷`。
  * 每个主机适配器都能看到这个`帧`，但是只有目的主机实际读取它。

使用一些`电缆`和叫做`网桥(bridge)`的小盒子，多个`以太网段`可以连接称较大的局域网，称为`桥接以太网(bridged Ethernet)`。

![j](.gitbook/assets/fN9znxV.png)

* 一些`电缆`连接网桥与网桥，或者 网桥与集线器。
  * 这些电缆的带宽可以是不同的。

![](.gitbook/assets/HiQyXb7.png)

在层次的更高级别，多个不兼容的局域网可以通过叫做`路由器(router)`的特殊计算机连接起来，组成一个`internet(互联网络)`

> Internet和internet  
>   
> 我们总是用小写字母的`internet`表示一般概念，大写的`Internet`表示一种具体实现，如全球IP因特网。

* `WAN`\(`Wide-Area Network`，广域网\)

![j](.gitbook/assets/oJUwlJs.png)

互联网至关重要的**特性**是:

* 它能由采用完全不同和**不兼容**技术的各种局域网和广域网组成。

`Q`:如何能够让某台`源主机`跨过所有这些不兼容的网络发送数据位到另一台`目的主机`呢?

`A`:解决办法是一层运行在每台主机和路由器上的`协议软件`，消除不同网络之间的差异。

* 这个软件实现一种`协议`:控制主机和路由器如何协调工作来实现数据传输。
  * 必须提供两种基本能力:
    * `命名机制`
      * 每台主机会被分配至少一个`互联网地址(internet address)`,这个地址唯一标识了这台主机。
    * `传送机制`
      * `协议`通过定义一种把数据位捆扎成不连续的片\(称为`包`\)的方式。
        * 一个`包`是由`包头`和`有效载荷`组成的。
          * `包头`
            * `包的大小`
            * `源主机`和`目的主机`地址
          * `有效载荷`包括从源主机发出的数据位

![k](.gitbook/assets/Nnjj0dR.png)

一个`客户端`运行在主机`A`上，主机`A`与`LAN1`相连，它发送了一串数据字节到运行在主机B上的服务器端，主机B则连接在`LAN2`上。有如下8个步骤。

1. 运行在主机`A`上的客户端进行系统调用，从客户端的`虚拟地址空间`拷贝到`内核缓冲区`。
2. 主机`A`上的`协议软件`通过在数据前附加互联网络`包头`和`LAN1`帧头，创建了一个`LAN1`的帧。
   * `互联网包头`寻址到互联网主机B。\(最终目的\)
   * `LAN1帧头`寻址到`路由器`。\(中转站\)
   * 封装
     * `LAN1帧`的**有效载荷**是`互联网络包`。
     * `互联网络包`的**有效载荷**是实际的用户数据。
     * 这种`封装`是基本的网络互联方法之一。
3. `LAN1`适配器拷贝该`帧`到网络上。
4. `帧`到达路由器，路由器的`LAN1适配器`从电缆上读取它，并传送到协议软件中。
5. 路由器从`互联网包头中`提取处目的互联网络地址，用它作为路由器的索引，确定向哪里转发这个包。
   * 路由器剥落旧的`LAN1`的帧头，加上寻址到主机`B`的新的`LAN2`帧头，并把得到的帧传送到适配器。
6. 路由器的`LAN2适配器`拷贝该`帧`到网络
7. `帧`到达主机B时，它的适配器从电缆上读到此帧，并将它传送到协议软件。
8. 最后，主机B上的协议软件剥落包头和帧头。服务器进行一个读取这些数据的`系统调用`。

当然，在这里，我们掩盖了许多非常艰难的问题。

* 如果不同的网络有不同`帧`大小的最大值，该怎么办。
* 路由器如何知道往哪里转发`帧`。
* 网络拓扑变化的时候，如何通知路由器。
* 包丢失了，会如何?

虽然如此，我们也能大概了解到互联网络思想的精髓。

## 全球 IP 因特网

![l](.gitbook/assets/T3BNTQy.png)

每台因特网主机都运行实现`TCP/IP`协议 \(Transmission Control Protocol/Intelnet Protocol,传输控制协议/互联网络协议\)的软件，几乎所有计算机系统都支持这个`协议`。

* 因特网的客户端和服务端混合使用`套接字接口`函数和`Unix I/O`函数来进行通信。
  * `套接字函数`典型地是作为会陷入内核的`系统调用`来实现的，并调用各种内核模式的`TCP/IP`函数。

`TCP/IP`协议实际上一个`协议族`，每一个协议提供不同的功能。

* 例
  * `IP`协议提供基本的命名方法，和传递机制。
    * 这种`传递机制`能够从一台因特网主机往其他主机发送包，也叫做`数据报(datagram)`
    * `IP`机制从某种意义上是不可靠的，如果数据报在网络丢失或重复，并不会试图恢复。
      * `UDP(Unreliable Datagram Protocol,不可靠数据报协议)`稍微扩展了`IP`协议。
        * 这样，`包`可以在`进程`间，而不是`主机`间传送。
  * `TCP`是一个构建在`IP`之上的复杂协议，提供了进程间可靠地`全双工(双向)`的连接。

为了简化讨论

* 我们将`TCP/IP`看作是一个单独的整体协议。
* 不讨论它的内部工作，只讨论`TCP`和`IP`为应用程序提供的基本功能。
* 不讨论`UDP`

从程序员的角度，我们可以把因特网看作世界范围内主机的集合，满足一下特性。

* 主机集合被映射为一组`32`位的`IP`地址。
* 这组`IP`地址可以被映射为一组称为`因特网域名(Internet domain name)`的标示符。
* 因特网主机上的进程能够通过`连接`和任何其他主机上的进程通信。

### IP地址

一个`IP`地址就是一个32位无符号整数。网络程序将`IP`地址存放在一个`IP地址结构`中, 并且是大端表示法.

```c
/* Internet address structure */
#include<arpa/inet.h>
struct in_addr{
    unsigned int s_addr;
}

大端表示法存储.
IP : 168.122.34.1
s_addr = 2826576385
  十六进制 =  0xA8 7A 22 01
    二进制 = 1010 1000 0111 1010 0010 0010 0000 0001
```

> 为什么要用结构来存放标量`IP`地址  
>   
> 是早期的不幸产物，但是现在更改太迟了。

**Unix提供下面这样的函数在网络\(大端\)和主机字节顺序\(小端\)之间实现转换.**

```c
#include <arpa/inet.h>
typedef unsigned int    uint32_t;
typedef unsigned short  uint16_t;

uint32_t htonl(uint32_t hostlong);        //本 转 网 IP    h  to n l
uint16_t htons(uint16_t hostshort);       //本 转 网 端口   h  to n s

uint32_t ntohl(uint32_t netlong);        //网 转 本 IP     n to h l
uint16_t ntohs(uint16_t netshort);       //网 转 本 端口    n to h s
```

 

IP地址通常是以一种称为`点分十进制表示法`来表示的

* 这里，每个`字节`\(8位\)都是由它的十进制表示\(0~255\)，并且用句点和其他字节间分开。
* 在Linux系统上，你能够使用`hostname`命令来确定你自己主机的点分十进制:

  ```text
    linux> hostname -i
    10.174.204.145
  ```

* **可以使用`inet_pton`和`inet_ntop`函数来实现两者之间互相转换。**

```c
#include <arpa/inet.h>
int inet_pton(int famuly, const char* src, void* dst);
	/*
        点分十进制字符串 转无符号int网络字节序(大端).
        	 famuly: 是IP地址协议族, AF_INET , AF_INET6
              src: 需要转换的十进制字符串
              dst: 接受转换完成的网络字节序,一般使用 struct in_addr 结构体来接收.
          返回值: 成功返回1, src参数非法则返回0, 出错返回-1
          			 当famuly 参数设置出错时会将errno 设置成 EAFNOSUPPORT 
   */    

const char* inet_ntop(int famuly, const void* src, char* dst, socklen_t size);
	/*
        无符号int网络字节序转点分十进制字符串 (ASCII码).
          famuly: 是IP地址协议族, AF_INET , AF_INET6
             src: 网络字节序地址, 一般还是 struct in_addr 结构体
             dst: 接受转换完成后的点分十进制地址字符串,字符串长度和size取值相同.
             size: 表示的是 dst 数组的大小. 应该取用 <netinet/in.h> 中的两个宏定义值:
             		      IPv4 : INET_ADDRSTRLEN    等于16
             		      IPv6 : INET6_ADDRSTRLEN   等于46
          返回值: 成功指向点分十进制字符串的指针(指向dst), 出错返回 NULL
           			 当famuly 参数设置出错时会将errno 设置成 EAFNOSUPPORT
                 如果 size 值过小,那么返回NULL, 将errno 设置为 ENOSPC
	*/

函数名中 p和n 分别代表 表达(字符串) 和数值(地址).
```

### 因特网域名

方便人们记忆的对于`IP`的映射就是`域名`。

`域名集合`形成了一个层次结构，每个域名编码了它在层次中的位置.

![k](.gitbook/assets/3XVt4jl.png)

* 叶子结点反向到根的`路径`就是`域名`。
* 层次结构第一层 : 未命名的根结点
* 层次结构第二层 : `一级域名(first-level domain name)`
  * 由非盈利组织`ICANN`\(Internet Corporation for Assigned Names and Numbers,因特尔分配名字数字协会\)定义。
  * 常见的一级域名:`com`,`edu`,`gov`,`org`和`net`。
* 层次结构第三层: `二级域名(second-level)`
  * 例如:`cmu.edu`。
  * 这些域名是由`ICANN`的各个授权代理按照先到先服务的基础分配的。
  * 一旦一个组织得到一个二级域名，那么它就可以在这个子域中创建任何新的域名了。



因特网定义了`域名集合`和`IP`地址直接的映射。

* `HOSTS.TXT`
  * 直到`1988`年，这个映射都是通过一个叫做`HOSTS.TXT`的文本文件来手工维护的。
* `DNS`:
  * 之后，通过分布世界范围内的数据库\(`DNS`，`Domain Name System`,域名系统\)，来维护的。
  * `DNS`数据库由上百万的`主机条目结构(host entry structure)`组成的。
    * 定义了一组`域名`\(一个官方名字和一个别名\)和一组`IP`地址之间的映射。

{% hint style="info" %}
每台因特网主机都有本地定义的域名  localhost  , 这个域名总是映射为 **回送地址 `127.0.0.1`**

#### 可以使用命令  nslookup   来进行查看,和解析,\(会出现无法解析的情况\)

* Linux&gt;   nslookup  localhost
  * 输出:      Address:  127.0.0.1
* Linux&gt;   nslookup  www.baidu.com
  * 输出:      Address: 61.135.169.125
  {% endhint %}



### 因特网连接

`Internet`服务端和客户端通过在`连接`上发送和接收`字节流`来通信。

* 从连接一对进程的意义上而言，连接是`点对点`的。
* 从数据可以同时双向流动的角度来说，它是`全双工`的。
* 并且从由源进程发出的字节流最终被目的进程按照发送的数据接收来说，它是`可靠`的

一个`套接字`是`连接的`一个端点。

* 每个套接字都有相应的`套接字地址`。
  * 是由一个`IP`地址和一个16位的整数`端口`组成的，用`地址:端口`来表示。
* 当客户端发起一个连接请求时，**客户端**套接字地址中的`端口`由内核**自动分配**的。
  * 称为`临时端口`
* **然后**，服务器套接字地址中的`端口`通常是某个**知名的端口**，和这个服务相对应的。
  * 例如:
    * **Web服务器**通常使用端口`80`
    * **电子邮件服务器**使用端口`25`
  * 在`Unix`机器上，文件`/etc/services` 包含一张这台机器提供的服务和他们的知名端口号的综合列表。

一个`连接`是由它两端的**套接字地址**唯一确定的。

* 这对套接字地址叫做`套接字对(socket pair)`,由下列元组来表示:
  * `(cliaddr:cliport,servaddr:servport)`



![a](.gitbook/assets/1SceWbw.png)



## 套接字接口

`套接字接口(socket interface)`是一组函数，他们和`Unix I/O`函数结合起来，用以创建网络应用。

给出一个典型的**客户端-服务器事务**的上下文中`套接字接口`概述，以此导向。

![j](.gitbook/assets/kyVfcmT.png)

![](.gitbook/assets/rFbybKQ.png)



### 套接字地址结构

不同的角度:

* 从`Unix`内核角度来看，一个套接字就是通信的一个`端点`。
* 从`Unix`程序来看，套接字就是一个有相应描述符的打开文件。

#### 套接字地址结构

```c
IP地址结构, IP和端口号走势以网络字节顺序(大端)存放的.
#include <sys/socket.h>

struct sockaddr_in{                    /* 保存套接字地址 (网络字节序)*/
    uint16_t        sin_family;        /* 协议族,IP4给 AF_INET, IP6给AF_INET6 */
    uint16_t        sin_port;          /* 端口号 */
    struct in_addr  sin_addr;          /* 用来存储IPv4地址的结构体(网络字节序),定义在IP*/
    unsigned char   sin_zero[8];       /* 结构长度垫到 sizeof（struct sockaddr）相同*/
};

struct in_addr {        // 用来存储 IPv4 的地址
    unsigned int  s_addr ;          /* internet地址, 32位IPv4 地址 (网络字节序) */
};

struct sockaddr{                /* 通用套接字地址结构, connect(), bind(), accept() */
    uint16_t  sa_family;        /* 协议族,IP4给 AF_INET, IP6给AF_INET6 */
    char      sa_adta[14];      /* 14 字节的协议地址, (有可能会更长)  */
};
```

`Internet`的套接字地址\(`Internet-sytle`\)存放在类型为`sockaddr_in`的16字节结构中。

* `sin_family`成员是`AF_INET`，ipv4还是ipv6。
* `sin_port`成员是一个16位的端口号。
* `sin_addr`成员就是一个32位的`IP`地址。
  * `IP`地址和端口号总是以网络字节顺序\(大端法\)存放的。
* `sin_zero` 是填充，使得`sockaddr_in`和`sockaddr`一样大。

`sockaddr_in`给程序员操作的，`sockaddr`交由套接字函数使用的，两者可以直接强制转换。

```c
typedef  struct  sockaddr SA;   
    #为了强转方便,那么这么来定义,以方便下面代码的书写和阅读.
```



### socket 函数 \(客户端+服务器\)

客户端和服务端使用`socket`函数来创建一个`套接字描述符(socket descriptor)`

跟`open`差不多

```c
#include <sys/types.h>
#include <sys/socket.h>

int socket(int family, int type, int protocol);

      family 参数:  协议族   AF_INET        ipv4网域  
                           AF_INET6       ipv6网域
			   	                 AF_LOCAL       Unix域协议(本地套接字),取代了AF_UNIX
			   	                 AF_ROUTE       路由套接字
			   	                 AF_KEY         密钥套接字
      type  参数:  指定采用的哪种协议,也就是套接字的类型.
      								SOCK_STREAM   字节流套接字, TCP 会采用
      								SOCK_DGRAM    数据报套接字, UDP 会采用
                      SOCK_SEQPACKET     有序分组套接字, SCTP 会采用
      								SOCK_RAW      原始套接字, 允许对底层协议的直接访问, 用于新网络协议测试
      protocol  参数: 给0 就好了, 表示按给定的域和套接字类型选择默认协议. 下面都是0表示的常值.
                         IPPROTO_CP    TCP传输协议,
                         IPPROTO_UDP   UDP传输协议
                         IPPROTO_SCTP  SCTP传输协议
	 返回值:  是一个文件描述符, (就是个套接字)可以使用IO 文件操作来进行读写.  否则-1
           创建出来的返回值就是套接字.

famil和type参数组合规则:
	SOCK_STREAM 可以和: AF_INET, AF_INET6, AF_LOCAL 组合,表示TCP/SCTP使用IPv4/v6以及本地套接字
	SOCK_DGRAM  可以和: AF_INET, AF_INET6, AF_LOCAL 组合,表示UDP使用IPv4/v6 以及本地套接字
  SOCK_SEQPACKET 可以和: AF_INET, AF_INET6, AF_LOCAL 组合,表示SCTP使用IPv4/v6 以及本地套接字
  SOCK_RAW 可以和: AF_INET, AF_INET6, AF_ROUTE, AF_KEY 组合,表示直接使用IPv4/v6的底层协议套接字.

/************************************************************/    
范例:  int lfd = socket(AF_INET, SOCK_STREAM, 0);
```

我们总是带这样的参数调用`socket`函数:

```c
clientfd = Socket(AF_INET,SOCK_STREAM,0);
```

* `AF_INET`表面我们在使用IPV4协议。
* `SOCK_STREAM`表示这个套接字是**`TCP 流式协议。`**
* `socket`返回的`clientfd`描述符，仅仅是部分打开，还不能用于读写。
  * 如何完成打开套接字的工作，取决于我们是客户端还是服务器。
  * 下一节描述我们是客户端时如何打开套接字。

### conect 函数\(客户端\)

**TCP客户端通过调用`connect`函数来建立和TCP服务器的连接**

```c
#include<sys/socket.h>

创建与指定外部端口的连接 (一般是客户端用来连接服务端的函数)
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
                sockfd  参数: 套接字
                addr    参数: 服务器端的IP和端口
                addrlen 参数: 第二个参数的长度
        返回值: 成功返回0 ,否则-1, 并且把error设置一个值.

    范例:    struct sockaddr_in server;
            connect(lfd, (struct sockaddr*)&server, sizeof(server));
```

`connect`函数试图于套接字地址为`serv_addr`的服务器建立一个因特网连接.

* 其中`addrlen`是`sizeof(sockaddr_in)`.
* `connect`函数会**阻塞**，一直到连接成功建立或是发生错误。
* 如果成功，`sockfd`描述符就可以读写了。
  * 并且得到链接是由套接字对`(x:y,serv_addr.sin_addr,serv_addr.sin_port)`刻画的。
    * 其中`x`是客户端IP地址，而`y`表示临时端口。
    * 它唯一地确立了客户端主机上的客户端进程。

###  bind 函数,  listen函数, accept函数 \(服务器\)

#### bind

剩下的套接字函数`bind`，`listen`和`accept`被服务器用来和客户端建立链接。

```c
#include<sys/socket.h>
将本地的IP 和端口 与创建出的套接字绑定 (客户端不需要绑定, 只有服务端需要)
int bind( int scokfd, const struct sockaddr* myaddr, socklen_t addrlen);
    sockfd  参数: 创建出的文件描述符
    myaddr  参数: 端口和IP  (是个结构体),可以使用 sockaddr_in 强转 sockaddr 来使用.
      					 如果端口参数为0,则内核会临时指定一个端口.
                 如果地址为通配地址,那么内核等到套接字已连接(TCP),或发送数据,才选择一个本地IP地址
                    IPv4通配地址由 INADDR_ANY 指定(值),serv.sin_addr.s_addr=htonl(INADDR_ANY);
                    IPv6通配地址由 in6addr_any 指定(结构),serv.sin6_addr=in6addr_any;
    addrlen 参数: sockaddr 结构体的长度.
 返回值: 成功返回 0
        失败返回-1, 并且把error设置一个值
         常见的错误返回值是 EADDRINUSE 地址已使用(用端口复用即可解决)
        
 范例:   struct sockaddr_in server;  
         bind(lfd, (struct sockaddr*)&server, sizeof(server)); 
```

`bind`函数告诉内核将`my_addr`中的服务器套接字地址和套接字描述符`sockfd`联系起来。

* 参数`addrlen`就是`sizeof(sockaddr_in)`

#### listen

客户端是发起连接请求的主动实体。服务器是等待来自客户端连接请求的被动实体。

* **默认情况**下，内核会认为`socket`函数创建的描述符对应于`主动套接字(active socket)`.
  * 它存在于一个连接的客户端。
* 服务器调用`listen`告诉内核，描述符是被**服务器**而不是客户端使用的

```c
#include<sys/socket.h>
设置监听同时连接到服务器的客户端的个数
 int listen(int sockfd, int backlog);
                sockfd  参数: socket函数创建出来的文件描述符
                backlong参数: 同时连接的个数,填写同时连接的最大值 128 就可以了
        返回值: 成功返回 0
               失败返回-1, 并且把error设置一个值

    范例:   listen(fd, 20);
```

`listen`函数将`sockfd`从一个`主动套接字`转化为一个`监听套接字(listenning socket)`。

* 该套接字可以接收来自客户端的连接请求。
* `backlog`参数暗示了内核在开始拒绝连接请求之前，应该放入队列中等待的未完成连接请求的数量。
  * `backlog`参数的确切含义要求对`TCP/IP`协议的理解，这超出了我们的讨论的范围。
  * 通常我们会把它设置成一个较大的值，比如`1024`。

#### accept

```c
#include <sys/socketc.h>
阻塞等待客户端连接请求,并接受连接 (阻塞函数)
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t* addrlen);
         sockfd  参数: 文件描述符, 使用socket 创建出的 监听套接字描述符                      
         cliaddr 参数: 存储客户端的端口和IP, 传出参数.协议地址
         addrlen 参数: 传入传出参数. (是cliaddr 的字节数大小),必须另行指定.

        返回值: 返回的是一个全新的套接字描述符, 对应客户端TCP连接的已连接描述符
                服务器端与客户端进程通信使用 accept 的返回值对应的套接字.
              如果失败则返回 -1 ,并且把errno 设置一个值.
            
* 如果该函数等待连接阻塞时,被信号中断了,那么errno会被设置成 EINTR ,并且返回 -1.那么解决方式是:
   int ffd = accept(lfd, (struct sockaddr*)&client, &len);   // 出现信号,然后去处理,回来之后就解除阻塞了
   while(ffd == -1 && errno == EINTR ){
        ffd = accept(lfd, (struct sockaddr*)&client, &len);   // 再来一次就可以了,
    }                                                         // 如果再次被信号中断,那也出不去循环.
    范例:    struct sockaddr_in client;
            socklen_t  len = sizeof(client);
            int cfd = accept(lfd,(struct sockaddr*)&client, &len);
```

* 用于从已完成连接`队列`队头返回下一个已完成连接。
  * 如果已完成连接为空，那么进程进入阻塞\(假定套接字为默认的阻塞方式\)
* 返回三个值
  * `已连接标示符`
  * `客户端地址`
  * `客户度地址长度`

`监听描述符`和`已连接描述符`之间的区别是很多人迷惑。

* `监听描述符`是作为**客户端连接请求**的一个端点。
  * 它被创建一次，并存在于**服务器**的整个生命周期。
* `已连接描述符`是客户端和服务器之间已经建立起来的**连接**的一个端点。
  * 服务器每次接收连接请求时都会创建一次。
  * 它只存在于服务器为一个客户端服务的过程中。

![.](.gitbook/assets/ping-mu-kuai-zhao-20190926-shang-wu-10.46.33.png)

### 主机和服务的转换

Linux 提供了一些强大的函数 \( 称为 **`getaddrinfo`** 和 **`getnameinfo`** \) 实现二进制套接字地址结构和主机名, 主机地址, 服务名 和 端口号的字符串表示之间的相互转化.  和套接字地址一起使用时,这些函数能使我们编写独立于任何特定版本的IP协议的网络程序.

#### 都会用到的数据结构

```c
struct addrinfo {
    int              ai_flags;     /* 提示参数标志,是一个掩码位, AI_xxx */
    int              ai_family;    /* IP4或IP6 , 用作 socket() 第一个参数 */
    int              ai_socktype;  /* 表示采用通讯协议,用作 socket() 第二个参数 */
    int              ai_protocol;  /* 表示按给定的域和套接字类型选择默认协议,用作 socket() 第三个参数 */
    char            *ai_canonname; /* 无需设置, 是主机域名 */
    size_t           ai_addrlen;   /* 无需设置, ai_addr结构体的大小,用作connect()和bind()的第三个参数 */
    struct sockaddr *ai_addr;      /* 无需设置, 套接字结构地址指针,用作connect()和bind()的第二个参数*/
    struct addrinfo *ai_next;      /* 无需设置, 指向链接列表中的下一个项目 */
};
需要设置的是三个变量: ai_flags, ai_family, ai_socktype.
    ai_flags :  AI_ADDRCONFIG 当前主机是IP4时,getaddrinfo() 就返回IP4地址,IP6同理, 如果不设置, 那么IP4和IP6都返回
                AI_CANONNAME   告诉函数getaddrinfo(), 第一个参数是 域名 而不是IP地址.
                AI_NUMERICSERV  告诉函数 getaddrinfo() 和 getnameinfo(), 参数service是端口号而不是服务名
                AI_PASSIVE     告诉getaddrinfo() 默认返回套接字地址会被服务器用作监听套接字, 而且host参数必须是NULL
    ai_family:  AF_INET    IP4地址
                AF_INET6   IP6地址
  ai_socktype:  SOCK_STREAM    TCP流式协议
                SOCK_DGRAM     UDP报式协议
                SOCK_RAW       允许地产协议的直接访问, 用于新网络协议测试

服务器设置该结构示例:     TCP协议, 使用端口号, IP4 地址
    struct addrinfo  addr, *serv;  /* 用来初始化和接收 getaddrinfo 参数和返回值的 */
    int  err = 0;
    memset(&addr, 0, sizeof(struct addrinfo));
    addr.ai_flags = AI_ADDRCONFIG | AI_NUMERICSERV | AI_PASSIVE;
    addr.ai_family = AF_INET;
    addr.socktype = SOCK_STREAM;
    if( (err = getaddrinfo(NULL,"80",&addr, &serv)) != 0)
        fprintf(strerr,"%s\n",gai_strerror(err));
    int fd = socket( serv->ai_family, serv->socktype, serv->ai_protocol);
    bind( fd, serv->ai_addr, serv->ai_addrlen);
    listen( fd, 1024);

    struct sockaddr client_in;   /* 这个用来存放客户端信息的结构,不是 addrinfo */
    size_t  clietn_in_len;
    char hostname[16] = { [1 ... 16-2]='\0','\0'};  /* 存放客户端IP地址 */
    char service[8] = { [1 ... 8-2]='\0','\0'};     /*存放客户端 端口号 */
    
    int cfd = accpet(fd, &client_in, &client_in_len);   /* 注意参数 */
    getnameinfo(&clent_in, client_in_len, hostname, sizeof(hostname),
                service, sizeof(service), 0);   /*获取客户端的IP地址和端口号*/
    printf("客户端IP = %s , 端口= %s \n", hostname, service );
    freeaddrinfo(&serv);        /* 一定要释放getaddrinfo 得到的数据结构 */
    

客户端设置示例:     TCP协议, 使用端口号, IP4地址
    struct addrinfo  addr, *serv;
    int  err = 0;
    memset(&addr, 0, sizeof(struct addrinfo));
    addr.ai_flags = AI_ADDRCONFIG | AI_NUMERICSERV ;  /* 这里体现了和服务器的区别*/
    addr.ai_family = AF_INET;
    addr.ai_socktype = SOCK_STREAM;
    if( (err = getaddrinfo("1.1.1.1","80",&addr, &serv)) != 0)  /* IP 不为NULL了 */
        fprintf(stderr, "%s\n", gai_strerror(err));
    int fd = socket( serv->ai_family, serv->socktype, serv->ai_protocol);
    conect( fd, serv->ar_addr, serv->ai_addrlen);   /*连接服务器*/
    freeaddrinfo(&serv);        /* 一定要释放getaddrinfo 得到的数据结构 */    
    
```

#### getaddrinfo 函数

```c
将  主机名, 主机地址, 服务名 和 端口号 的字符串表示转换成套接字地址结构.

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo( 
         const char* host,                /*服务器给NULL,客户端给 服务器的IP地址或域名*/
         const char* service,             /*端口号或服务名*/
         const struct addrinfo* hints,    /*一个数据结构,包含IP类型,协议类型,函数行为*/
         struct addrinfo** result         /*这个是返回的 addrinfo 结构的链表 */
         );
    参数:  host: 服务器给 NULL , 客户端给 服务器的IP地址或者域名
       service: 服务器写开放和监听端口号字符串, 客户端写服务器开发和监听的端口号字符串或 http
      addrinfo: 一个被 memset() 初始化 并且设置完成的 addrinfo 数据结构.
        result: 函数初始化并返回的一个二级指针,使用这个返回指针来进行操作,里面是初始化完成的结构.

返回值: 如果成功返回0, 错误则返回非零的错误代码.使用 gai_strerror(错误码); 来输出查看.
```

#### getnameinfo 函数

```c
将 套接字地址结构转换成相应的 主机和服务名字符串. ( 和getaddrinfo() 作用相反 ),一般用在服务器端.
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int  getnameinfo(
    const struct sockaddr* sa,   /* 通过 accect 得到的第二个参数的数据结构,里面包含IP和端口号*/
    socklen_t   salen,           /* sockaddr 的结构大小 ,就是第一个参数测大小*/
    char*   host,                /* 保存 IP或域名的 字符串, 如果是IP长度给16,域名则要长很多*/
    size_t  hostlen,             /* host 字符串的长度 */
    char*   service,             /* 保存 端口号 或者 服务名 字符串 */
    size_t  servlen,             /*  service 字符串 长度 */
    int   flage                  /* 位掩码, 能够修改默认行为 */
    );
可设置的变量  flage : NI_NUMERICHOST  强制向 host 参数写入IP地址,而不是域名
                    NI_NUMERICSERV  向 service 写入端口号, 而不是服务名

文件 /etc/services  记录着 端口和服务名 之间的映射. 可以进行查询.
```

## Web服务器 和 HTTP

**Web客户端和服务器之间的交互用的是一个基于文本的`应用级协议`, `HTTP`;**

一个Web客户端\(浏览器\) 打开一个到服务器的因特网连接, 并且**请求**某些内容.  服务器相应所请求的内容,**然后关闭连接**.  浏览器读取这些内容, 并把它显示在屏幕上.

* 通信过程
  * 一个Web客户端\(浏览器\) 打开一个到服务器的因特网连接,
    * 并且**`请求`**某些内容.
  * 服务器**`响应`**所请求的内容
    * **然后关闭连接**
  * 浏览器读取这些内容
    * 并把它显示在屏幕上

Web内容可以用一种叫做  **`HTML`** \(超文本标记语言\) 的语言来编写.   一个HTML程序\(页\) 包含指令\(标记\) ,他们告诉浏览器如何显示这页中的各种文本和图形对象.

HTML 强大之处在于一个页面可以包含指针\(超链接\) :   **`<a href="网址" >Carnegie Mellon</a>`**

### Web内容

对于Web 服务器和客户端而言,  内容是与一个 MIME\(多用途的网际邮件扩充协议\) 类型相关的字节序列.

{% hint style="info" %}
常用的 MIME 类型

* **text/html**
  * HTML 页面
* **text/plain**
  * 无格式文本
* **application/postscript**
  * Postscript 文档
* **image/gif**
  * GIF 格式编码的二进制图像
* **image/png**
  * PNG 格式编码的二进制图像
* **image/jpeg**
  * JPEG 格式编码的二进制图像
* **wav**
  * audio/wav
* **mp3**
  * audio/mpeg
* **avi**
  * video/x-msvideo
* **mov**
  * video/quicktime
  {% endhint %}

Web服务器以两种不同的方式向客户端提供内容

* 取一个磁盘文件,并将它的内容返回给客户端, 磁盘文件称为**静态内容**
  * 而返回文件给客户端的过程称为 **服务静态内容**
* 运行一个可执行文件, 并将它的输出返回给客户端. 运行时可执行文件产生的输出称为 **动态内容**
  * 运行程序并返回它的输出到客户端的过程称为 **服务动态内容**

{% hint style="info" %}
每条由  Web 服务器返回的内容都是和它管理的某个文件关联的,  这些文件中的每个都有一个唯一个名字, 叫做 **`URL`**\(通用资源定位符\). 是URI 的一个子集.

**`http://www.google.com:80/index.html`**

可执行文件的 URL可以在文件名后面包括程序参数, "?" 字符分隔文件名和参数,而且每个参数都用 "&" 字符分隔开.

**`http://www.ppt.com:80/cgi-bin/adder?15000&113`**

* 标识了一个叫做 /cgi-bin/adder 的可执行文件
  * 会带两个参数字符串 15000 和 113 来调用他

#### 在事务过程中, 客户端和服务器使用的是 URL 的不同部分,  

* 客户端使用的是前缀, 来决定与哪类服务器联系,服务器在哪里,以及它监听的端口号是多少
  * **`http://www.google.com:80`**
* 服务器使用后缀,来发现它文件系统中的文件, 并确定请求的是**静态内容**还是**动态内容.**
  * **/index.html**

**最小的URL后缀是""/字符, 所有的服务器将其扩展为某个默认主页, 如 /index.html ,  也就是说在浏览器中渐入一个域名就可以取出一个网站的主页.**  

**浏览器在 URL 后添加缺失的 "/", 并将之传递给服务器, 服务器又把 "/" 扩展到某个默认的文件名.**
{% endhint %}

### **HTTP事务**

**可以使用 telnet 命令来和因特网上的任何 Web 服务器执行事务. 对于调试通过文本行来与客户端对话的服务器来说, 是非常便利的.**

```bash
一个静态内容的 HTTP 事务;
请求行, 请求报头,  相应行, 响应报头, html响应主体 .这些内容在C 中每行结尾都必须是 "\r\n"

linux>  telnet   www.aol.com  80        客户端:  打开与服务器的连接
Trying 98.136.100.146...                telnet命令打印三行到终端
Connected to aol.com.
Escape character is '^]'.
GET / HTTP/1.1                          这一行是我们输入的请求行: GET请求  URI HTTP版本
Host: www.aol.com                       请求报头,也就是原始服务器的域名(有代理服务器时会有用)
                                        这里必须有一个回车 来表示请求报头结束
HTTP/1.1 200  OK                        服务器: 服务器返回的响应头:  HTTP版本 状态码 描述
Date: Thu, 26 Sep 2019 10:40:59 GMT     服务器: 除http外,下面所有行都是服务器返回的响应报头
Connection: keep-alive                       
Server: ATS                                 使用的服务器型号
Cache-Control: no-store
Content-Type: text/html                     服务器返回内容的 MIME类型
Content-Language: en                         返回HTML 的语言,就是英语
Location: https://www.aol.com/               返回的HTML 文件所在的位置(就是域名/位置)
Content-Length: 3144                         响应主体的大小为3144字节(就是HTML文件的大小)
                                        这个空行表示响应报头终止
<html>                                从这里开始是 响应主体
...
</html>                               响应主体结束
Connection closed by foreign host.      关闭连接
```

* 服务器响应头返回的一些常见的**状态码**
  * **200**
    * **成功**,  处理请求无误
  * **301**
    * **永久移动**.   内容已经移动到 location 头中指明的主机上
  * **400**
    * **错误请求**.  服务器不能理解的请求
  * **403**
    * **禁止**.   服务器无权访问所请求的文件
  * **404**
    * **未发现.** 服务器不能找到所请求的文件
  * **501**
    * **未发现.**  服务器不支持请求的方法
  * **505**
    * **HTTP版本不支持.**   服务器不支持请求的版本**.**

### 服务动态内容

**`CGI`\(通用网关接口\)标准解决了如下问题:**

* 客户端 如何将程序参数传递给服务器?
  * 客户端通过URL来访问服务器.   
    * **`http://www.pp.com/a.out?113&443`**  
    * 113 和 443 就是程序 a.out 的参数.
* 服务器如何将这些参数传递给它所创建的子进程?
* 服务器如何将子进程生成内容所需要的其他信息传递给子进程?
* 子进程将它的输出发送到哪里?

#### 1. 客户端如何将程序参数传递给服务器

GET请求的参数在 URI 中传递.  一个 "**`?`**" 字符分隔了文件名和参数, 而每个参数都用一个"**`&`**"字符分隔开. 参数中不允许带有空格, 而必须用字符串"**`%20`**" 来表示. 对其他字符 也有相似的编码.

#### 2. 服务器如何将参数传递给子进程

在服务器收到这条请求行后:  **`GET /cgi-bin/adder?15000&213  HTTP/1.1`**

* **它调用  `fork()` 来创建子进程.**
* **并且调用 `execve()` 在子进程的上下文中执行 `/cgi-bin/adder` 程序.**
  * `像 adder 这种程序常常被称为`  **`CGI程序.`**`因为它们遵守CGI标准的规则.`
    * 因为许多 CGI程序都是用 Perl 脚本写的. 所以CGI程序也常被称为 CGI脚本.
* 调用 **`execve()`** 之前,  **子进程将** `CGI环境变量`  **`QUERY_STRING`** 设置为 **`"15000&213",`**\(仅限这个范例程序\)
  * **fork\(\)**之后, 子进程执行的内容:   **`setenv("QUERY_STRING","15000 213",1);`**
  * 在 **adder** 程序执行时,可以使用 **`getenv`**函数引用它:   **`char buf[1024] = getenv("QUERY_STRING");`**

#### 3. 服务器如何将其他信息传递给子进程

CGI定义了大量的其他环境变量, 一个CGI程序在运行时可以设置这些环境变量

* **QUERY\_STRING**
  * `程序参数,  (例如 "15000 213")`
* **SERVER\_PORT**
  * `父进程侦听的端口`
* **REQUEST\_METHOD**
  * `GET 或 POST`
* **REMOTE\_HOST**
  * `客户端的域名`
* **REMOTE\_ADDR**
  * `客户端的点分十进制IP地址`
* **CONTENT\_TYPE**
  * `只对 POST 而言:  请求体的 MIME类型`
* **CONTENT\_LENGTH**
  * `只对 POST 而言: 请求体的字节大小`

#### 4. 子进程将它的输出发送到哪里

**一个CGI 程序将它的动态内容发送到标准输出.**

{% hint style="info" %}
子进程在加载并运行CGI程序之前 \(就是 execve函数之前\) 使用 dup2 函数将标准输出重定向到和客户端相关联的已连接描述符, 因此任何 CGI 程序写到标准输出的东西都会直达客户端.

注意:  因为父进程不知道子进程生成的内容类型或大小, 所以子进程要负责生成 **`Content-type (MIME类型)`**和 **`Content-length (响应主体大小)`** 响应报头, 以及终止报头的空行.
{% endhint %}

```c
一个简单的 CGI程序, 他对两个参数求和,并带回结果的 HTML文件给客户端.
    在此之前,服务器程序以及设置了环境变量和重定位了 STDOUT_FILENO 描述符.
服务器运行下面程序之前执行的一部分代码
    if( fork() == 0)
    {
        setenv("QUERY_STRING", "15000 213", 1);
        dup2(和客户端通讯的套接字描述符, STDOUT_FILENO );
        execve( "./a.out" ,emptylist, environ);
        /*  下面这个程序名是  a.out
              emptylist : 是 char* emptylist[] 数组,包含执行 a.out时的参数(不是运行)
              environ   : 全局环境变量列表 ,这个参数是固定的, 
    }

/* CGI 程序    a.out  */
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define  MAXLINE  4096

int main(void) {
    char *buf, *p;
    char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];
    int n1=0, n2=0;

    /* Extract the two arguments */
    if ((buf = getenv("QUERY_STRING")) != NULL) {
	p = strchr(buf, '&');
	*p = '\0';
	strcpy(arg1, buf);
	strcpy(arg2, p+1);
	n1 = atoi(arg1);
	n2 = atoi(arg2);
    }

    /* Make the response body */
    sprintf(content, "Welcome to add.com: ");
    sprintf(content, "%sTHE Internet addition portal.\r\n<p>", content);
    sprintf(content, "%sThe answer is: %d + %d = %d\r\n<p>", 
	    content, n1, n2, n1 + n2);
    sprintf(content, "%sThanks for visiting!\r\n", content);
  
    /* Generate the HTTP response */
    printf("Connection: close\r\n");
    printf("Content-length: %d\r\n", (int)strlen(content));
    printf("Content-type: text/html\r\n\r\n");
    printf("%s", content);
    fflush(stdout);

    exit(0);
}
```

### 综合  :  TINY Web 服务器

个人研究完了, 不想把笔记写的乱七八糟, 就直接复制源码了.  一共三个源码文件.

{% code-tabs %}
{% code-tabs-item title="main.c" %}
```c
/* $begin tinymain */
/*
 * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the 
 *     GET method to serve static and dynamic content.
 */
#include "csapp.h"

struct sockaddr_in a;


void doit(int fd);
void read_requesthdrs(rio_t *rp);
int parse_uri(char *uri, char *filename, char *cgiargs);
void serve_static(int fd, char *filename, int filesize);
void get_filetype(char *filename, char *filetype);
void serve_dynamic(int fd, char *filename, char *cgiargs);
void clienterror(int fd, char *cause, char *errnum, 
        char *shortmsg, char *longmsg);

int main(int argc, char **argv) 
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    /* Check command line args */
    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(1);
    }

    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(clientaddr);
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen); //line:netp:tiny:accept
        Getnameinfo((SA *) &clientaddr, clientlen, hostname, MAXLINE, 
                port, MAXLINE, 0);
        printf("Accepted connection from (%s, %s)\n", hostname, port);
        doit(connfd);                                             //line:netp:tiny:doit
        Close(connfd);                                            //line:netp:tiny:close
    }
}
/* $end tinymain */

/*
 * doit - handle one HTTP request/response transaction
 */
/* $begin doit */
void doit(int fd) 
{
    int is_static;
    struct stat sbuf;
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    char filename[MAXLINE], cgiargs[MAXLINE];
    rio_t rio;

    /* Read request line and headers */
    Rio_readinitb(&rio, fd);
    if (!Rio_readlineb(&rio, buf, MAXLINE))  //line:netp:doit:readrequest
        return;
    printf("%s", buf);
    sscanf(buf, "%s %s %s", method, uri, version);       //line:netp:doit:parserequest
    if (strcasecmp(method, "GET")) {                     //line:netp:doit:beginrequesterr
        clienterror(fd, method, "501", "Not Implemented",
                "Tiny does not implement this method");
        return;
    }                                                    //line:netp:doit:endrequesterr
    read_requesthdrs(&rio);                              //line:netp:doit:readrequesthdrs

    /* Parse URI from GET request */
    is_static = parse_uri(uri, filename, cgiargs);       //line:netp:doit:staticcheck
    if (stat(filename, &sbuf) < 0) {                     //line:netp:doit:beginnotfound
        clienterror(fd, filename, "404", "Not found",
                "Tiny couldn't find this file");
        return;
    }                                                    //line:netp:doit:endnotfound

    if (is_static) { /* Serve static content */          
        if (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR & sbuf.st_mode)) { //line:netp:doit:readable
            clienterror(fd, filename, "403", "Forbidden",
                    "Tiny couldn't read the file");
            return;
        }
        serve_static(fd, filename, sbuf.st_size);        //line:netp:doit:servestatic
    }
    else { /* Serve dynamic content */
        if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR & sbuf.st_mode)) { //line:netp:doit:executable
            clienterror(fd, filename, "403", "Forbidden",
                    "Tiny couldn't run the CGI program");
            return;
        }
        serve_dynamic(fd, filename, cgiargs);            //line:netp:doit:servedynamic
    }
}
/* $end doit */

/*
 * read_requesthdrs - read HTTP request headers
 */
/* $begin read_requesthdrs */
void read_requesthdrs(rio_t *rp) 
{
    char buf[MAXLINE];

    Rio_readlineb(rp, buf, MAXLINE);
    printf("%s", buf);
    while(strcmp(buf, "\r\n")) {          //line:netp:readhdrs:checkterm
        Rio_readlineb(rp, buf, MAXLINE);
        printf("%s", buf);
    }
    return;
}
/* $end read_requesthdrs */

/*
 * parse_uri - parse URI into filename and CGI args
 *             return 0 if dynamic content, 1 if static
 */
/* $begin parse_uri */
int parse_uri(char *uri, char *filename, char *cgiargs) 
{
    char *ptr;

    if (!strstr(uri, "cgi-bin")) {  /* Static content */ //line:netp:parseuri:isstatic
        strcpy(cgiargs, "");                             //line:netp:parseuri:clearcgi
        strcpy(filename, ".");                           //line:netp:parseuri:beginconvert1
        strcat(filename, uri);                           //line:netp:parseuri:endconvert1
        if (uri[strlen(uri)-1] == '/')                   //line:netp:parseuri:slashcheck
            strcat(filename, "home.html");               //line:netp:parseuri:appenddefault
        return 1;
    }
    else {  /* Dynamic content */                        //line:netp:parseuri:isdynamic
        ptr = index(uri, '?');                           //line:netp:parseuri:beginextract
        if (ptr) {
            strcpy(cgiargs, ptr+1);
            *ptr = '\0';
        }
        else 
            strcpy(cgiargs, "");                         //line:netp:parseuri:endextract
        strcpy(filename, ".");                           //line:netp:parseuri:beginconvert2
        strcat(filename, uri);                           //line:netp:parseuri:endconvert2
        return 0;
    }
}
/* $end parse_uri */

/*
 * serve_static - copy a file back to the client 
 */
/* $begin serve_static */
void serve_static(int fd, char *filename, int filesize) 
{
    int srcfd;
    char *srcp, filetype[MAXLINE], buf[MAXBUF];

    /* Send response headers to client */
    get_filetype(filename, filetype);       //line:netp:servestatic:getfiletype
    sprintf(buf, "HTTP/1.0 200 OK\r\n");    //line:netp:servestatic:beginserve
    sprintf(buf, "%sServer: Tiny Web Server\r\n", buf);
    sprintf(buf, "%sConnection: close\r\n", buf);
    sprintf(buf, "%sContent-length: %d\r\n", buf, filesize);
    sprintf(buf, "%sContent-type: %s\r\n\r\n", buf, filetype);
    Rio_writen(fd, buf, strlen(buf));       //line:netp:servestatic:endserve
    printf("Response headers:\n");
    printf("%s", buf);

    /* Send response body to client */
    srcfd = Open(filename, O_RDONLY, 0);    //line:netp:servestatic:open
    srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);//line:netp:servestatic:mmap
    Close(srcfd);                           //line:netp:servestatic:close
    Rio_writen(fd, srcp, filesize);         //line:netp:servestatic:write
    Munmap(srcp, filesize);                 //line:netp:servestatic:munmap
}

/*
 * get_filetype - derive file type from file name
 */
void get_filetype(char *filename, char *filetype) 
{
    if (strstr(filename, ".html"))
        strcpy(filetype, "text/html");
    else if (strstr(filename, ".gif"))
        strcpy(filetype, "image/gif");
    else if (strstr(filename, ".png"))
        strcpy(filetype, "image/png");
    else if (strstr(filename, ".jpg"))
        strcpy(filetype, "image/jpeg");
    else
        strcpy(filetype, "text/plain");
}  
/* $end serve_static */

/*
 * serve_dynamic - run a CGI program on behalf of the client
 */
/* $begin serve_dynamic */
void serve_dynamic(int fd, char *filename, char *cgiargs) 
{
    char buf[MAXLINE], *emptylist[] = { NULL };

    /* Return first part of HTTP response */
    sprintf(buf, "HTTP/1.0 200 OK\r\n"); 
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Server: Tiny Web Server\r\n");
    Rio_writen(fd, buf, strlen(buf));

    if (Fork() == 0) { /* Child */ //line:netp:servedynamic:fork
        /* Real server would set all CGI vars here */
        setenv("QUERY_STRING", cgiargs, 1); //line:netp:servedynamic:setenv
        Dup2(fd, STDOUT_FILENO);         /* Redirect stdout to client */ //line:netp:servedynamic:dup2
        Execve(filename, emptylist, environ); /* Run CGI program */ //line:netp:servedynamic:execve
    }
    Wait(NULL); /* Parent waits for and reaps child */ //line:netp:servedynamic:wait
}
/* $end serve_dynamic */

/*
 * clienterror - returns an error message to the client
 */
/* $begin clienterror */
void clienterror(int fd, char *cause, char *errnum, 
        char *shortmsg, char *longmsg) 
{
    char buf[MAXLINE], body[MAXBUF];

    /* Build the HTTP response body */
    sprintf(body, "<html><title>Tiny Error</title>");
    sprintf(body, "%s<body bgcolor=""ffffff"">\r\n", body);
    sprintf(body, "%s%s: %s\r\n", body, errnum, shortmsg);
    sprintf(body, "%s<p>%s: %s\r\n", body, longmsg, cause);
    sprintf(body, "%s<hr><em>The Tiny Web server</em>\r\n", body);

    /* Print the HTTP response */
    sprintf(buf, "HTTP/1.0 %s %s\r\n", errnum, shortmsg);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-type: text/html\r\n");
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-length: %d\r\n\r\n", (int)strlen(body));
    Rio_writen(fd, buf, strlen(buf));
    Rio_writen(fd, body, strlen(body));
}
/* $end clienterror */


```
{% endcode-tabs-item %}

{% code-tabs-item title="csapp.c" %}
```c
/* 
 * Updated 8/14 droh: 
 *   - open_clientfd and open_listenfd are now reentrant and protocol
 *     independent.
 *
 *   - Added protocol-independent inet_ntop and inet_pton functions. The
 *     inet_ntoa and inet_aton functions are obsolete.
 *
 * Updated 7/14 droh:
 *   - Aded reentrant sio (signal-safe I/O) routines
 * 
 * Updated 4/13 droh: 
 *   - rio_readlineb: fixed edge case bug
 *   - rio_readnb: removed redundant EINTR check
 */
/* $begin csapp.c */
#include "csapp.h"

/************************** 
 * Error-handling functions
 **************************/
/* $begin errorfuns */
/* $begin unixerror */
void unix_error(char *msg) /* Unix-style error */
{
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}
/* $end unixerror */

void posix_error(int code, char *msg) /* Posix-style error */
{
    fprintf(stderr, "%s: %s\n", msg, strerror(code));
    exit(0);
}

void dns_error(char *msg)
{
    fprintf(stderr, "%s\n", msg);
    exit(0);
}

void gai_error(int code, char *msg) /* Getaddrinfo-style error */
{
    fprintf(stderr, "%s: %s\n", msg, gai_strerror(code));
    exit(0);
}

void app_error(char *msg) /* Application error */
{
    fprintf(stderr, "%s\n", msg);
    exit(0);
}
/* $end errorfuns */

/*********************************************
 * Wrappers for Unix process control functions
 ********************************************/

/* $begin forkwrapper */
pid_t Fork(void) 
{
    pid_t pid;

    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
/* $end forkwrapper */

void Execve(const char *filename, char *const argv[], char *const envp[]) 
{
    if (execve(filename, argv, envp) < 0)
        unix_error("Execve error");
}

/* $begin wait */
pid_t Wait(int *status) 
{
    pid_t pid;

    if ((pid  = wait(status)) < 0)
        unix_error("Wait error");
    return pid;
}
/* $end wait */

pid_t Waitpid(pid_t pid, int *iptr, int options) 
{
    pid_t retpid;

    if ((retpid  = waitpid(pid, iptr, options)) < 0) 
        unix_error("Waitpid error");
    return(retpid);
}

/* $begin kill */
void Kill(pid_t pid, int signum) 
{
    int rc;

    if ((rc = kill(pid, signum)) < 0)
        unix_error("Kill error");
}
/* $end kill */

void Pause() 
{
    (void)pause();
    return;
}

unsigned int Sleep(unsigned int secs) 
{
    unsigned int rc;

    if ((rc = sleep(secs)) < 0)
        unix_error("Sleep error");
    return rc;
}

unsigned int Alarm(unsigned int seconds) {
    return alarm(seconds);
}

void Setpgid(pid_t pid, pid_t pgid) {
    int rc;

    if ((rc = setpgid(pid, pgid)) < 0)
        unix_error("Setpgid error");
    return;
}

pid_t Getpgrp(void) {
    return getpgrp();
}

/************************************
 * Wrappers for Unix signal functions 
 ***********************************/

/* $begin sigaction */
handler_t *Signal(int signum, handler_t *handler) 
{
    struct sigaction action, old_action;

    action.sa_handler = handler;  
    sigemptyset(&action.sa_mask); /* Block sigs of type being handled */
    action.sa_flags = SA_RESTART; /* Restart syscalls if possible */

    if (sigaction(signum, &action, &old_action) < 0)
        unix_error("Signal error");
    return (old_action.sa_handler);
}
/* $end sigaction */

void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
{
    if (sigprocmask(how, set, oldset) < 0)
        unix_error("Sigprocmask error");
    return;
}

void Sigemptyset(sigset_t *set)
{
    if (sigemptyset(set) < 0)
        unix_error("Sigemptyset error");
    return;
}

void Sigfillset(sigset_t *set)
{ 
    if (sigfillset(set) < 0)
        unix_error("Sigfillset error");
    return;
}

void Sigaddset(sigset_t *set, int signum)
{
    if (sigaddset(set, signum) < 0)
        unix_error("Sigaddset error");
    return;
}

void Sigdelset(sigset_t *set, int signum)
{
    if (sigdelset(set, signum) < 0)
        unix_error("Sigdelset error");
    return;
}

int Sigismember(const sigset_t *set, int signum)
{
    int rc;
    if ((rc = sigismember(set, signum)) < 0)
        unix_error("Sigismember error");
    return rc;
}

int Sigsuspend(const sigset_t *set)
{
    int rc = sigsuspend(set); /* always returns -1 */
    if (errno != EINTR)
        unix_error("Sigsuspend error");
    return rc;
}

/*************************************************************
 * The Sio (Signal-safe I/O) package - simple reentrant output
 * functions that are safe for signal handlers.
 *************************************************************/

/* Private sio functions */

/* $begin sioprivate */
/* sio_reverse - Reverse a string (from K&R) */
static void sio_reverse(char s[])
{
    int c, i, j;

    for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}

/* sio_ltoa - Convert long to base b string (from K&R) */
static void sio_ltoa(long v, char s[], int b) 
{
    int c, i = 0;

    do {  
        s[i++] = ((c = (v % b)) < 10)  ?  c + '0' : c - 10 + 'a';
    } while ((v /= b) > 0);
    s[i] = '\0';
    sio_reverse(s);
}

/* sio_strlen - Return length of string (from K&R) */
static size_t sio_strlen(char s[])
{
    int i = 0;

    while (s[i] != '\0')
        ++i;
    return i;
}
/* $end sioprivate */

/* Public Sio functions */
/* $begin siopublic */

ssize_t sio_puts(char s[]) /* Put string */
{
    return write(STDOUT_FILENO, s, sio_strlen(s)); //line:csapp:siostrlen
}

ssize_t sio_putl(long v) /* Put long */
{
    char s[128];

    sio_ltoa(v, s, 10); /* Based on K&R itoa() */  //line:csapp:sioltoa
    return sio_puts(s);
}

void sio_error(char s[]) /* Put error message and exit */
{
    sio_puts(s);
    _exit(1);                                      //line:csapp:sioexit
}
/* $end siopublic */

/*******************************
 * Wrappers for the SIO routines
 ******************************/
ssize_t Sio_putl(long v)
{
    ssize_t n;

    if ((n = sio_putl(v)) < 0)
        sio_error("Sio_putl error");
    return n;
}

ssize_t Sio_puts(char s[])
{
    ssize_t n;

    if ((n = sio_puts(s)) < 0)
        sio_error("Sio_puts error");
    return n;
}

void Sio_error(char s[])
{
    sio_error(s);
}

/********************************
 * Wrappers for Unix I/O routines
 ********************************/

int Open(const char *pathname, int flags, mode_t mode) 
{
    int rc;

    if ((rc = open(pathname, flags, mode))  < 0)
        unix_error("Open error");
    return rc;
}

ssize_t Read(int fd, void *buf, size_t count) 
{
    ssize_t rc;

    if ((rc = read(fd, buf, count)) < 0) 
        unix_error("Read error");
    return rc;
}

ssize_t Write(int fd, const void *buf, size_t count) 
{
    ssize_t rc;

    if ((rc = write(fd, buf, count)) < 0)
        unix_error("Write error");
    return rc;
}

off_t Lseek(int fildes, off_t offset, int whence) 
{
    off_t rc;

    if ((rc = lseek(fildes, offset, whence)) < 0)
        unix_error("Lseek error");
    return rc;
}

void Close(int fd) 
{
    int rc;

    if ((rc = close(fd)) < 0)
        unix_error("Close error");
}

int Select(int  n, fd_set *readfds, fd_set *writefds,
        fd_set *exceptfds, struct timeval *timeout) 
{
    int rc;

    if ((rc = select(n, readfds, writefds, exceptfds, timeout)) < 0)
        unix_error("Select error");
    return rc;
}

int Dup2(int fd1, int fd2) 
{
    int rc;

    if ((rc = dup2(fd1, fd2)) < 0)
        unix_error("Dup2 error");
    return rc;
}

void Stat(const char *filename, struct stat *buf) 
{
    if (stat(filename, buf) < 0)
        unix_error("Stat error");
}

void Fstat(int fd, struct stat *buf) 
{
    if (fstat(fd, buf) < 0)
        unix_error("Fstat error");
}

/*********************************
 * Wrappers for directory function
 *********************************/

DIR *Opendir(const char *name) 
{
    DIR *dirp = opendir(name); 

    if (!dirp)
        unix_error("opendir error");
    return dirp;
}

struct dirent *Readdir(DIR *dirp)
{
    struct dirent *dep;

    errno = 0;
    dep = readdir(dirp);
    if ((dep == NULL) && (errno != 0))
        unix_error("readdir error");
    return dep;
}

int Closedir(DIR *dirp) 
{
    int rc;

    if ((rc = closedir(dirp)) < 0)
        unix_error("closedir error");
    return rc;
}

/***************************************
 * Wrappers for memory mapping functions
 ***************************************/
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset) 
{
    void *ptr;

    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))
        unix_error("mmap error");
    return(ptr);
}

void Munmap(void *start, size_t length) 
{
    if (munmap(start, length) < 0)
        unix_error("munmap error");
}

/***************************************************
 * Wrappers for dynamic storage allocation functions
 ***************************************************/

void *Malloc(size_t size) 
{
    void *p;

    if ((p  = malloc(size)) == NULL)
        unix_error("Malloc error");
    return p;
}

void *Realloc(void *ptr, size_t size) 
{
    void *p;

    if ((p  = realloc(ptr, size)) == NULL)
        unix_error("Realloc error");
    return p;
}

void *Calloc(size_t nmemb, size_t size) 
{
    void *p;

    if ((p = calloc(nmemb, size)) == NULL)
        unix_error("Calloc error");
    return p;
}

void Free(void *ptr) 
{
    free(ptr);
}

/******************************************
 * Wrappers for the Standard I/O functions.
 ******************************************/
void Fclose(FILE *fp) 
{
    if (fclose(fp) != 0)
        unix_error("Fclose error");
}

FILE *Fdopen(int fd, const char *type) 
{
    FILE *fp;

    if ((fp = fdopen(fd, type)) == NULL)
        unix_error("Fdopen error");

    return fp;
}

char *Fgets(char *ptr, int n, FILE *stream) 
{
    char *rptr;

    if (((rptr = fgets(ptr, n, stream)) == NULL) && ferror(stream))
        app_error("Fgets error");

    return rptr;
}

FILE *Fopen(const char *filename, const char *mode) 
{
    FILE *fp;

    if ((fp = fopen(filename, mode)) == NULL)
        unix_error("Fopen error");

    return fp;
}

void Fputs(const char *ptr, FILE *stream) 
{
    if (fputs(ptr, stream) == EOF)
        unix_error("Fputs error");
}

size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
    size_t n;

    if (((n = fread(ptr, size, nmemb, stream)) < nmemb) && ferror(stream)) 
        unix_error("Fread error");
    return n;
}

void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
    if (fwrite(ptr, size, nmemb, stream) < nmemb)
        unix_error("Fwrite error");
}


/**************************** 
 * Sockets interface wrappers
 ****************************/

int Socket(int domain, int type, int protocol) 
{
    int rc;

    if ((rc = socket(domain, type, protocol)) < 0)
        unix_error("Socket error");
    return rc;
}

void Setsockopt(int s, int level, int optname, const void *optval, int optlen) 
{
    int rc;

    if ((rc = setsockopt(s, level, optname, optval, optlen)) < 0)
        unix_error("Setsockopt error");
}

void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) 
{
    int rc;

    if ((rc = bind(sockfd, my_addr, addrlen)) < 0)
        unix_error("Bind error");
}

void Listen(int s, int backlog) 
{
    int rc;

    if ((rc = listen(s,  backlog)) < 0)
        unix_error("Listen error");
}

int Accept(int s, struct sockaddr *addr, socklen_t *addrlen) 
{
    int rc;

    if ((rc = accept(s, addr, addrlen)) < 0)
        unix_error("Accept error");
    return rc;
}

void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) 
{
    int rc;

    if ((rc = connect(sockfd, serv_addr, addrlen)) < 0)
        unix_error("Connect error");
}

/*******************************
 * Protocol-independent wrappers
 *******************************/
void Getaddrinfo(const char *node, const char *service, 
        const struct addrinfo *hints, struct addrinfo **res)
{
    int rc;

    if ((rc = getaddrinfo(node, service, hints, res)) != 0) 
        gai_error(rc, "Getaddrinfo error");
}

void Getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, 
        size_t hostlen, char *serv, size_t servlen, int flags)
{
    int rc;

    if ((rc = getnameinfo(sa, salen, host, hostlen, serv, 
                    servlen, flags)) != 0) 
        gai_error(rc, "Getnameinfo error");
}

void Freeaddrinfo(struct addrinfo *res)
{
    freeaddrinfo(res);
}

void Inet_ntop(int af, const void *src, char *dst, socklen_t size)
{
    if (!inet_ntop(af, src, dst, size))
        unix_error("Inet_ntop error");
}

void Inet_pton(int af, const char *src, void *dst) 
{
    int rc;

    rc = inet_pton(af, src, dst);
    if (rc == 0)
        app_error("inet_pton error: invalid dotted-decimal address");
    else if (rc < 0)
        unix_error("Inet_pton error");
}

/*******************************************
 * DNS interface wrappers. 
 *
 * NOTE: These are obsolete because they are not thread safe. Use
 * getaddrinfo and getnameinfo instead
 ***********************************/

/* $begin gethostbyname */
struct hostent *Gethostbyname(const char *name) 
{
    struct hostent *p;

    if ((p = gethostbyname(name)) == NULL)
        dns_error("Gethostbyname error");
    return p;
}
/* $end gethostbyname */

struct hostent *Gethostbyaddr(const char *addr, int len, int type) 
{
    struct hostent *p;

    if ((p = gethostbyaddr(addr, len, type)) == NULL)
        dns_error("Gethostbyaddr error");
    return p;
}

/************************************************
 * Wrappers for Pthreads thread control functions
 ************************************************/

void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, 
        void * (*routine)(void *), void *argp) 
{
    int rc;

    if ((rc = pthread_create(tidp, attrp, routine, argp)) != 0)
        posix_error(rc, "Pthread_create error");
}

void Pthread_cancel(pthread_t tid) {
    int rc;

    if ((rc = pthread_cancel(tid)) != 0)
        posix_error(rc, "Pthread_cancel error");
}

void Pthread_join(pthread_t tid, void **thread_return) {
    int rc;

    if ((rc = pthread_join(tid, thread_return)) != 0)
        posix_error(rc, "Pthread_join error");
}

/* $begin detach */
void Pthread_detach(pthread_t tid) {
    int rc;

    if ((rc = pthread_detach(tid)) != 0)
        posix_error(rc, "Pthread_detach error");
}
/* $end detach */

void Pthread_exit(void *retval) {
    pthread_exit(retval);
}

pthread_t Pthread_self(void) {
    return pthread_self();
}

void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {
    pthread_once(once_control, init_function);
}

/*******************************
 * Wrappers for Posix semaphores
 *******************************/

void Sem_init(sem_t *sem, int pshared, unsigned int value) 
{
    if (sem_init(sem, pshared, value) < 0)
        unix_error("Sem_init error");
}

void P(sem_t *sem) 
{
    if (sem_wait(sem) < 0)
        unix_error("P error");
}

void V(sem_t *sem) 
{
    if (sem_post(sem) < 0)
        unix_error("V error");
}

/****************************************
 * The Rio package - Robust I/O functions
 ****************************************/

/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
        if ((nread = read(fd, bufp, nleft)) < 0) {
            if (errno == EINTR) /* Interrupted by sig handler return */
                nread = 0;      /* and call read() again */
            else
                return -1;      /* errno set by read() */ 
        } 
        else if (nread == 0)
            break;              /* EOF */
        nleft -= nread;
        bufp += nread;
    }
    return (n - nleft);         /* return >= 0 */
}
/* $end rio_readn */

/*
 * rio_writen - Robustly write n bytes (unbuffered)
 */
/* $begin rio_writen */
ssize_t rio_writen(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
        if ((nwritten = write(fd, bufp, nleft)) <= 0) {
            if (errno == EINTR)  /* Interrupted by sig handler return */
                nwritten = 0;    /* and call write() again */
            else
                return -1;       /* errno set by write() */
        }
        nleft -= nwritten;
        bufp += nwritten;
    }
    return n;
}
/* $end rio_writen */


/* 
 * rio_read - This is a wrapper for the Unix read() function that
 *    transfers min(n, rio_cnt) bytes from an internal buffer to a user
 *    buffer, where n is the number of bytes requested by the user and
 *    rio_cnt is the number of unread bytes in the internal buffer. On
 *    entry, rio_read() refills the internal buffer via a call to
 *    read() if the internal buffer is empty.
 */
/* $begin rio_read */
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;

    while (rp->rio_cnt <= 0) {  /* Refill if buf is empty */
        rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
                sizeof(rp->rio_buf));
        if (rp->rio_cnt < 0) {
            if (errno != EINTR) /* Interrupted by sig handler return */
                return -1;
        }
        else if (rp->rio_cnt == 0)  /* EOF */
            return 0;
        else 
            rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */
    }

    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
    cnt = n;          
    if (rp->rio_cnt < n)   
        cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
/* $end rio_read */

/*
 * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
 */
/* $begin rio_readinitb */
void rio_readinitb(rio_t *rp, int fd) 
{
    rp->rio_fd = fd;  
    rp->rio_cnt = 0;  
    rp->rio_bufptr = rp->rio_buf;
}
/* $end rio_readinitb */

/*
 * rio_readnb - Robustly read n bytes (buffered)
 */
/* $begin rio_readnb */
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
        if ((nread = rio_read(rp, bufp, nleft)) < 0) 
            return -1;          /* errno set by read() */ 
        else if (nread == 0)
            break;              /* EOF */
        nleft -= nread;
        bufp += nread;
    }
    return (n - nleft);         /* return >= 0 */
}
/* $end rio_readnb */

/* 
 * rio_readlineb - Robustly read a text line (buffered)
 */
/* $begin rio_readlineb */
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
    int n, rc;
    char c, *bufp = usrbuf;

    for (n = 1; n < maxlen; n++) { 
        if ((rc = rio_read(rp, &c, 1)) == 1) {
            *bufp++ = c;
            if (c == '\n') {
                n++;
                break;
            }
        } else if (rc == 0) {
            if (n == 1) {
                return 0; /* EOF, no data read */
            }
            else {
                break;    /* EOF, some data was read */
            }
        } else
            return -1;	  /* Error */
    }
    *bufp = '\0';
    return n-1;
}
/* $end rio_readlineb */

/**********************************
 * Wrappers for robust I/O routines
 **********************************/
ssize_t Rio_readn(int fd, void *ptr, size_t nbytes) 
{
    ssize_t n;

    if ((n = rio_readn(fd, ptr, nbytes)) < 0)
        unix_error("Rio_readn error");
    return n;
}

void Rio_writen(int fd, void *usrbuf, size_t n) 
{
    if (rio_writen(fd, usrbuf, n) != n)
        unix_error("Rio_writen error");
}

void Rio_readinitb(rio_t *rp, int fd)
{
    rio_readinitb(rp, fd);
} 

ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
    ssize_t rc;

    if ((rc = rio_readnb(rp, usrbuf, n)) < 0)
        unix_error("Rio_readnb error");
    return rc;
}

ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
    ssize_t rc;

    if ((rc = rio_readlineb(rp, usrbuf, maxlen)) < 0)
        unix_error("Rio_readlineb error");
    return rc;
} 

/******************************** 
 * Client/server helper functions
 ********************************/
/*
 * open_clientfd - Open connection to server at <hostname, port> and
 *     return a socket descriptor ready for reading and writing. This
 *     function is reentrant and protocol-independent.
 * 
 *     On error, returns -1 and sets errno.  
 */
/* $begin open_clientfd */
int open_clientfd(char *hostname, char *port) {
    int clientfd;
    struct addrinfo hints, *listp, *p;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;  /* Open a connection */
    hints.ai_flags = AI_NUMERICSERV;  /* ... using a numeric port arg. */
    hints.ai_flags |= AI_ADDRCONFIG;  /* Recommended for connections */
    Getaddrinfo(hostname, port, &hints, &listp);

    /* Walk the list for one that we can successfully connect to */
    for (p = listp; p; p = p->ai_next) {

        /* Create the socket descriptor */
        if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) 
            continue; /* Socket failed, try the next */
        if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1) 
            break; /* Success */
        Close(clientfd); /* Connect failed, try another */
    } 

    /* Clean up */
    Freeaddrinfo(listp);
    if (!p) /* All connects failed */
        return -1;
    else    /* The last connect succeeded */
        return clientfd;
}
/* $end open_clientfd */

/*  
 * open_listenfd - Open and return a listening socket on port. This
 *     function is reentrant and protocol-independent.
 *
 *     On error, returns -1 and sets errno.
 */
/* $begin open_listenfd */
int open_listenfd(char *port) 
{
    struct addrinfo hints, *listp, *p;
    int listenfd, optval=1;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;  /* Accept TCP connections */
    hints.ai_flags = AI_PASSIVE;      /* ... on any IP address */
    hints.ai_flags |= AI_NUMERICSERV; /* ... using a numeric port arg. */
    hints.ai_flags |= AI_ADDRCONFIG;  /* Recommended for connections */
    Getaddrinfo(NULL, port, &hints, &listp);

    /* Walk the list for one that we can bind to */
    for (p = listp; p; p = p->ai_next) {

        /* Create a socket descriptor */
        if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) 
            continue;  /* Socket failed, try the next */

        /* Eliminates "Address already in use" error from bind */
        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, 
                (const void *)&optval , sizeof(int));

        /* Bind the descriptor to the address */
        if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
            break; /* Success */
        Close(listenfd); /* Bind failed, try the next */
    }

    /* Clean up */
    Freeaddrinfo(listp);
    if (!p) /* No address worked */
        return -1;

    /* Make it a listening socket ready to accept connection requests */
    if (listen(listenfd, LISTENQ) < 0)
        return -1;
    return listenfd;
}
/* $end open_listenfd */

/****************************************************
 * Wrappers for reentrant protocol-independent helpers
 ****************************************************/
int Open_clientfd(char *hostname, char *port) 
{
    int rc;

    if ((rc = open_clientfd(hostname, port)) < 0) 
        unix_error("Open_clientfd error");
    return rc;
}

int Open_listenfd(char *port) 
{
    int rc;

    if ((rc = open_listenfd(port)) < 0)
        unix_error("Open_listenfd error");
    return rc;
}

/* $end csapp.c */





```
{% endcode-tabs-item %}

{% code-tabs-item title="csapp.h" %}
```c
/* $begin csapp.h */
#ifndef __CSAPP_H__
#define __CSAPP_H__

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <setjmp.h>
#include <signal.h>
#include <dirent.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <errno.h>
#include <math.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>

/* Default file permissions are DEF_MODE & ~DEF_UMASK */
/* $begin createmasks */
#define DEF_MODE   S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
#define DEF_UMASK  S_IWGRP|S_IWOTH
/* $end createmasks */

/* Simplifies calls to bind(), connect(), and accept() */
/* $begin sockaddrdef */
typedef struct sockaddr SA;
/* $end sockaddrdef */

/* Persistent state for the robust I/O (Rio) package */
/* $begin rio_t */
#define RIO_BUFSIZE 8192
typedef struct {
    int rio_fd;                /* Descriptor for this internal buf */
    int rio_cnt;               /* Unread bytes in internal buf */
    char *rio_bufptr;          /* Next unread byte in internal buf */
    char rio_buf[RIO_BUFSIZE]; /* Internal buffer */
} rio_t;
/* $end rio_t */

/* External variables */
extern int h_errno;    /* Defined by BIND for DNS errors */ 
extern char **environ; /* Defined by libc */

/* Misc constants */
#define	MAXLINE	 8192  /* Max text line length */
#define MAXBUF   8192  /* Max I/O buffer size */
#define LISTENQ  1024  /* Second argument to listen() */

/* Our own error-handling functions */
void unix_error(char *msg);
void posix_error(int code, char *msg);
void dns_error(char *msg);
void gai_error(int code, char *msg);
void app_error(char *msg);

/* Process control wrappers */
pid_t Fork(void);
void Execve(const char *filename, char *const argv[], char *const envp[]);
pid_t Wait(int *status);
pid_t Waitpid(pid_t pid, int *iptr, int options);
void Kill(pid_t pid, int signum);
unsigned int Sleep(unsigned int secs);
void Pause(void);
unsigned int Alarm(unsigned int seconds);
void Setpgid(pid_t pid, pid_t pgid);
pid_t Getpgrp();

/* Signal wrappers */
typedef void handler_t(int);
handler_t *Signal(int signum, handler_t *handler);
void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
void Sigemptyset(sigset_t *set);
void Sigfillset(sigset_t *set);
void Sigaddset(sigset_t *set, int signum);
void Sigdelset(sigset_t *set, int signum);
int Sigismember(const sigset_t *set, int signum);
int Sigsuspend(const sigset_t *set);

/* Sio (Signal-safe I/O) routines */
ssize_t sio_puts(char s[]);
ssize_t sio_putl(long v);
void sio_error(char s[]);

/* Sio wrappers */
ssize_t Sio_puts(char s[]);
ssize_t Sio_putl(long v);
void Sio_error(char s[]);

/* Unix I/O wrappers */
int Open(const char *pathname, int flags, mode_t mode);
ssize_t Read(int fd, void *buf, size_t count);
ssize_t Write(int fd, const void *buf, size_t count);
off_t Lseek(int fildes, off_t offset, int whence);
void Close(int fd);
int Select(int  n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
        struct timeval *timeout);
int Dup2(int fd1, int fd2);
void Stat(const char *filename, struct stat *buf);
void Fstat(int fd, struct stat *buf) ;

/* Directory wrappers */
DIR *Opendir(const char *name);
struct dirent *Readdir(DIR *dirp);
int Closedir(DIR *dirp);

/* Memory mapping wrappers */
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
void Munmap(void *start, size_t length);

/* Standard I/O wrappers */
void Fclose(FILE *fp);
FILE *Fdopen(int fd, const char *type);
char *Fgets(char *ptr, int n, FILE *stream);
FILE *Fopen(const char *filename, const char *mode);
void Fputs(const char *ptr, FILE *stream);
size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

/* Dynamic storage allocation wrappers */
void *Malloc(size_t size);
void *Realloc(void *ptr, size_t size);
void *Calloc(size_t nmemb, size_t size);
void Free(void *ptr);

/* Sockets interface wrappers */
int Socket(int domain, int type, int protocol);
void Setsockopt(int s, int level, int optname, const void *optval, int optlen);
void Bind(int sockfd, struct sockaddr *my_addr, int addrlen);
void Listen(int s, int backlog);
int Accept(int s, struct sockaddr *addr, socklen_t *addrlen);
void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen);

/* Protocol independent wrappers */
void Getaddrinfo(const char *node, const char *service, 
        const struct addrinfo *hints, struct addrinfo **res);
void Getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, 
        size_t hostlen, char *serv, size_t servlen, int flags);
void Freeaddrinfo(struct addrinfo *res);
void Inet_ntop(int af, const void *src, char *dst, socklen_t size);
void Inet_pton(int af, const char *src, void *dst); 

/* DNS wrappers */
struct hostent *Gethostbyname(const char *name);
struct hostent *Gethostbyaddr(const char *addr, int len, int type);

/* Pthreads thread control wrappers */
void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, 
        void * (*routine)(void *), void *argp);
void Pthread_join(pthread_t tid, void **thread_return);
void Pthread_cancel(pthread_t tid);
void Pthread_detach(pthread_t tid);
void Pthread_exit(void *retval);
pthread_t Pthread_self(void);
void Pthread_once(pthread_once_t *once_control, void (*init_function)());

/* POSIX semaphore wrappers */
void Sem_init(sem_t *sem, int pshared, unsigned int value);
void P(sem_t *sem);
void V(sem_t *sem);

/* Rio (Robust I/O) package */
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
void rio_readinitb(rio_t *rp, int fd); 
ssize_t	rio_readnb(rio_t *rp, void *usrbuf, size_t n);
ssize_t	rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);

/* Wrappers for Rio package */
ssize_t Rio_readn(int fd, void *usrbuf, size_t n);
void Rio_writen(int fd, void *usrbuf, size_t n);
void Rio_readinitb(rio_t *rp, int fd); 
ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n);
ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);

/* Reentrant protocol-independent client/server helpers */
int open_clientfd(char *hostname, char *port);
int open_listenfd(char *port);

/* Wrappers for reentrant protocol-independent client/server helpers */
int Open_clientfd(char *hostname, char *port);
int Open_listenfd(char *port);


#endif /* __CSAPP_H__ */
/* $end csapp.h */


```
{% endcode-tabs-item %}
{% endcode-tabs %}





